<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: puppet | Shit Gary Says]]></title>
  <link href="http://garylarizza.com/blog/categories/puppet/atom.xml" rel="self"/>
  <link href="http://garylarizza.com/"/>
  <updated>2017-08-24T21:06:38-05:00</updated>
  <id>http://garylarizza.com/</id>
  <author>
    <name><![CDATA[Gary larizza]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Roles and Profiles in a Control Repo?]]></title>
    <link href="http://garylarizza.com/blog/2017/01/17/roles-and-profiles-in-a-control-repo/"/>
    <updated>2017-01-17T13:14:36-06:00</updated>
    <id>http://garylarizza.com/blog/2017/01/17/roles-and-profiles-in-a-control-repo</id>
    <content type="html"><![CDATA[<p>In the past, the thing that got me to make a blog post was answering a question
more than once and not having a good source to point someone to after-the-fact.
As the docs at <a href="http://docs.puppet.com">docs.puppet.com</a> have become more
comprehensive, I find that I&rsquo;m wanting to write about things infrequently. But,
all it takes is a question or two from a customer to kick things in the
ass and remind me that there&rsquo;s still a <em>LOT</em> of tribal knowledge around Puppet
(let alone the greater community). It&rsquo;s with THAT theme that we talk about
Roles &amp; Profiles, and the Control Repo.</p>

<p><a href="https://docs.puppet.com/pe/latest/cmgmt_control_repo.html">Like many things nowadays, there are official Puppet docs on the Control Repo.</a>
In a nutshell, the Control Repo is the repository that Puppet&rsquo;s Code Manager
(or R10k in the open source) uses to track Puppet Environments and the versions
of all Puppet modules within each Puppet Environment. On a greater scale, the
Control Repo is an organization&rsquo;s implementation of Puppet to the extent that
it can (and eventually will) fully represent your organization&rsquo;s
infrastructure. Changes to the Control Repo WILL incur changes to your Puppet
Master(s), and in most cases will also bubble down to your managed nodes
(i.e. if you&rsquo;re changing a profile that&rsquo;s being used by 1000 nodes, then that
change will be definitely change the file that&rsquo;s on each Puppet Master but will
also change the enforcement of Puppet on those 1000 nodes).</p>

<p><a href="https://docs.puppet.com/pe/latest/r_n_p_intro.html">Similarly, Roles &amp; Profiles has its own official docs page!</a>
As a recap, &ldquo;Role &amp; Profiles&rdquo; is a design pattern (that&rsquo;s all!) that has been
employed by Puppet Users for several years as a way to make sense of wiring
up public Puppet modules with site-specific implementations and data. It allows
organizations to share common modules while also having the ability to add their
own customizations and implement a separate configuration management data layer
(i.e. Hiera).</p>

<p>Both the Control Repo and Roles &amp; Profiles (R&amp;P) have undergone several evolutions to
get them to the reliable state we know today, and they&rsquo;ve had their shared
history: we&rsquo;ve implemented Roles &amp; Profiles both inside and outside the Control Repo&hellip;</p>

<h2>Roles and Profiles outside the Control Repo</h2>

<p>Roles &amp; Profiles were (was?) created before the Control Repo because the problem of
disentangling data from Puppet code was a greater priority than automating
code-consistency across multiple Puppet masters. When the idea of using a git
repo to implement dynamic Puppet Environments came along, the success of
being able to ensure module consistency across all your masters was pretty
landmark. The workflow, however, needed some work &ndash; there were a LOT of steps.
Git workflow automation loves it some hooks, and so the idea of a post-receive hook
that would immediately update a Puppet environment was a logical landing point.
The idea was that all modules would be listed and &lsquo;pinned&rsquo; to their correct
version/tag/commit within <code>Puppetfile</code> that lived at the root of the Control
Repo. &lsquo;Roles&rsquo; and &lsquo;Profiles&rsquo; are Puppet modules, modules were already listed
in <code>Puppetfile</code>, so some customers listed them there initially. During a code
deploy, R10k/Code Manager would read that file, pull down all the modules at their
correct versions, and then move along. That entire workflow looked like this:</p>

<ol>
<li>Create/Modify a Profile and push changes to the Profile module repo</li>
<li>Create a branch to the Control Repo and modify <code>Puppetfile</code> to target the new Profile changes</li>
<li>Push the Control Repo changes up to the remote (where the git webhook catches that change and deploys it to Puppet Masters)</li>
<li>Classify your node (if needed) and/or test the changes</li>
<li>If changes are necessary, go back to step 1 and repeat up to step 4</li>
<li>Once everything works, submit a Pull Request to the Control Repo</li>
</ol>


<p>This workflow works regardless of whether a Role or Profile was changed, but
the biggest thing to understand is that ONLY the Control Repo has the git webhook
that will deploy code changes to your Puppet Masters, so if you want to trigger
a code deploy then you&rsquo;ll need to change the Control Repo and push that change
up (or have access to trigger R10k/Code Manager on the Puppet Master). This
resulted in a lot of &lsquo;dummy&rsquo; changes that were necessary SOLELY to trigger a
code change. Conversely, changes to the Roles or Profiles module (they&rsquo;re separate)
don&rsquo;t get automatically replicated, so even if there&rsquo;s a small change to a
Profile you&rsquo;ll still need to either trigger R10k/Code Manager by hand or make
a small dummy commit to the Control Repo to trigger a code deploy.</p>

<p>As I said before, some customers implemented Roles &amp; Profiles and the Control Repo
this way for awhile until it was realized that you could save steps by putting
both the Roles and Profiles module into the Control Repo itself&hellip;</p>

<h2>Roles and Profiles inside the Control Repo</h2>

<p>Since the entire contents of the Control Repo are already cloned down to disk by
R10k/Code Manager, the idea came about to store the Roles and Profiles modules
in a special directory of the Control Repo (usually called &lsquo;site&rsquo; which is short
for &lsquo;site-specific modules&rsquo;), and then change <code>$modulepath</code> within Puppet to
look for the &lsquo;site&rsquo; folder within every Puppet Environment&rsquo;s directory path as
another place for Puppet modules to live. This worked for two reasons:</p>

<ol>
<li>It shortened the workflow (since changes to Roles and Profiles were done
within the history of the Control Repo, there was no need to change the
version &lsquo;pin&rsquo; inside <code>Puppetfile</code> as a separate step)</li>
<li>Because Roles and Profiles are now within the Control Repo, changes made to
Roles and Profiles will now trigger a code deploy</li>
</ol>


<p>For the vast majority of customers, putting Roles &amp; Profiles inside the Control
Repo made sense and kept the workflow shorter than it was before. It also had
the added benefit of turning the Control Repo into the important artifact that
it is today (thanks to the git webhook).</p>

<h2>Can/Should we also put other modules inside the Control Repo?</h2>

<p>Once you add the site directory to <code>$modulepath</code>, it opens up that directory to
be used as a place for storing ANY Puppet modules. The question then remains:
should the site directory be used for anything else other than Roles and Profiles?</p>

<p>Maybe?</p>

<p>Just like Puppet, though, just because you CAN do things, doesn&rsquo;t immediately
mean you SHOULD. It&rsquo;s important to understand that the Control Repo is
fundamental to ensuring code consistency across multiple Puppet Masters. For
that reason, commits to the Control Repo should be scruitinized closely. If
you&rsquo;re a large team with many Puppet contributers and many Puppet masters, then
it&rsquo;s best to keep modules within their own git repositories so multiple team
members can work independenly and the Control Repo can be used to &ldquo;tie it all
together&rdquo; in the end. If you&rsquo;re the only Puppet contributor, you&rsquo;re using 80%
of your modules from the Puppet Forge, but you have 3 relatively-static modules
outside of Roles and Profiles that you&rsquo;ve written specifically for your
organization and you want them in the site directory of the Control Repo then
you&rsquo;re probably fine. See the difference?</p>

<h2>Who owns what?</h2>

<p>One of the biggest factors to influence where Puppet modules should be managed
is the split of which teams own which decisions. Usually, Puppet infrastructure
is owned by an internal operations team, which means that the Ops team is used
to making changes to the Control Repo. If Puppet usage is wide enough within
your organization it&rsquo;s common to find application teams who own specific
Profiles that are separate from the infrastructure. It&rsquo;s usually easier to
grant an outside team access to a separate repo than it is to try and restrict
access to a specific folder or even branch of an existing repository, and so
in that case it might make sense to make the Profile module its own repository.
If the people that own the Puppet infrastructure are the same people that
make changes to Puppet modules, then it doesn&rsquo;t really matter where Roles and
Profiles go.</p>

<p>For many organizations this is THE consideration that determines their choice,
but remember to build a workflow for today with the ability to adapt to
tomorrow.  If you have a single person outside the ops team contributing to
Puppet, it doesn&rsquo;t mean that you need to upend the workflow just for them.
Moving from something like having Roles &amp; Profiles inside the Control Repo to
having them outside the Control Repo is an easy switch to implement (from
a technical standpoint), but the second you make that switch you&rsquo;re adding
steps to EVERYONE&rsquo;S workflow and changing the location of the most commonly
used modules within Puppet. That&rsquo;s a heavy cost &ndash; don&rsquo;t do it without reason.</p>

<h2>So what are the OFFICIAL RECOMMENDATIONS THEN?!?!</h2>

<p>We officially recommend you calm down with that punctuation. Beyond that, here it is:</p>

<ul>
<li>Put Roles &amp; Profiles within the site directory of the Control Repo unless you
have a specific reason NOT to.</li>
</ul>


<p>Do you have multiple Puppet contributors and separate modules for EACH
INDIVIDUAL Profile?  Then you might want to have separate repos for each
Profile and put them in <code>Puppetfile</code> to keep the development history separate.
You ALSO might want to put each individual Profile module in the site directory
of the Control Repo and just run with it that way. The bottom line here would
be access: who can/should access Profiles, who can/should access the Control
Repo, are those people the same, and do you need to restrict access for some
reason? Start with doing it this way and change WHEN YOU HIT THAT COMPLEXITY!
Don&rsquo;t deviate because you &lsquo;anticipate something&rsquo; &ndash; change when you&rsquo;re ready
for it and don&rsquo;t overarchitect early.</p>

<ul>
<li>If you&rsquo;re a smaller team with the same people who own the Puppet infrastructure
as who own Puppet module development and you have a couple of small internal modules
that don&rsquo;t change very often, AND putting them inside the &lsquo;site&rsquo; folder of
the Control Repo is easier for you than managing individual git repos, then by
all means do it!</li>
</ul>


<p>Whew that was a lot. Basically, yes, I&rsquo;ve outlined a narrow case because usually
creating a new git repository is a very small cost for an organization. If
you&rsquo;re in an organization where that&rsquo;s NOT the case, then the site directory
solution might appeal to you. What you gain in simplicity you lose in access
and security, though, so consider that ahead of time. Finally, the biggest factor
HERE is that the same people own the infrastructure and module code, so you can
afford to make shortcuts.</p>

<ul>
<li>Have an internal Puppet Policy/Style Guide for where Puppet modules &ldquo;go.&rdquo;</li>
</ul>


<p>If you&rsquo;ve had the conversation and made the decision, DOCUMENT IT! It&rsquo;s more
important to have an escalation path/policy for new Puppet users in your
organization to ensure consistency (the last thing you want to do is to keep
having this conversation every other month).</p>

<ul>
<li>Moving a module from the &lsquo;site&rsquo; directory to its own repository is not
difficult, but it does add workflow steps.</li>
</ul>


<p>Remember that if a module doesn&rsquo;t live in the &lsquo;site&rsquo; directory then it needs
to get &lsquo;pinned&rsquo; in <code>Puppetfile</code>, and that adds an extra step anytime that
module needs updated within a Puppet Environment.</p>

<h2>Summary</h2>

<p>First, if you&rsquo;ve read this post it&rsquo;s probably because you&rsquo;re Googling for
material to support your cause (or someone cited this post as evidence to back
their position). You might have even skipped down here for &ldquo;the answer.&rdquo; Guess
what &ndash; shit doesn&rsquo;t work like that! Storing Roles &amp; Profiles (and/or other
Puppet modules) within the &lsquo;site&rsquo; directory is an organizational choice based
on the workflow that best jives with an organization&rsquo;s existing developmental
cycle and ownership requirements. The costs/benefits for each choice boil down
to access, security, and saving time. The majority of the time putting Roles
&amp; Profiles in the Control Repo saves time and keeps all organizational-specific
information in one place.  If you don&rsquo;t have a great reason to change that,
then don&rsquo;t.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Workflows Evolved: Even Besterer Practices]]></title>
    <link href="http://garylarizza.com/blog/2015/11/16/workflows-evolved-even-besterer-practices/"/>
    <updated>2015-11-16T09:00:24-06:00</updated>
    <id>http://garylarizza.com/blog/2015/11/16/workflows-evolved-even-besterer-practices</id>
    <content type="html"><![CDATA[<p>It&rsquo;s nearly been two years since I posted the Puppet Workflow series and
several things have changed:</p>

<ul>
<li>R10k now ships with Puppet Enterprise and <a href="http://docs.puppetlabs.com/pe/latest/r10k.html">there are docs for it!</a></li>
<li>There&rsquo;s even a <a href="http://docs.puppetlabs.com/pe/latest/r10k_config_console.html"><code>pe_r10k</code> module</a> that ships with Puppet Enterprise 2015.2.x and higher to configure R10k</li>
<li><a href="https://github.com/puppetlabs/control-repo">Control repos are the standard and are popping up all over the place</a></li>
<li>Most people are bundling Hiera data with their Control repo (unless they have a very good reason not to)</li>
<li>Ditto for Roles and Profiles</li>
<li>The one-role-per-node rule is a good start, but PE&rsquo;s rules-based classification engine allows us to relax that rule</li>
<li>Roles still include Profiles, but conditional logic is allowed and recommended to keep Hiera hierarchy levels minimal</li>
<li>&lsquo;Data&rsquo; goes in Hiera, but the definition of &lsquo;data&rsquo; changes between organizations</li>
<li>There&rsquo;s now a (somewhat) defined path for whether &lsquo;data&rsquo; is included in a profile or Hiera</li>
<li>Automatic Parameter Lookup + Hiera&hellip;it&rsquo;s still hard to debug, but we&rsquo;re getting there</li>
<li>I&rsquo;m incredibly wary of taking Uber during peak travel times with rate multipliers</li>
</ul>


<p>It&rsquo;s been awhile since I&rsquo;ve had a good rant, so let&rsquo;s get right into it!</p>

<h2>Code Management with R10k</h2>

<p>As of PE 3.8, R10k became bundled with Puppet Enterprise (PE) and was referred
to as &ldquo;Code Management&rdquo; which initially confused people because the only thing
about PE that was changed was that the R10k gem was preinstalled into PE&rsquo;s Ruby
installation.  The purpose of this act was twofold:</p>

<ol>
<li>The Professional Services team was installing R10k in essentially EVERY services engagement, and so it made sense to ship R10k and thus officially support its installation</li>
<li>We&rsquo;ve always had plans to keep the functionality that R10k provided but not NECESSARILY the tool-known-as-R10k, so calling the service it provided something OTHER than R10k would allow us to swap out the implementation underneath the hood while still being able to talk about the functionality it provided</li>
</ol>


<p>Of course, if you didn&rsquo;t live inside Puppet Labs it&rsquo;s possible that you might not have gotten this
memo, but, hey: better late than never?</p>

<p>For various reasons, we also never initially shipped a PE-specific module to
configure R10k, so you ALSO had to either manually setup <code>r10k.yaml</code> or use
<a href="https://github.com/acidprime/r10k">Zack Smith&rsquo;s R10k module</a> to manage that file. Of course, that
module did all kinds of OTHER things (like installing the R10k gem, setting up
webhooks, and making my breakfast), which meant that if you used it with the
version of PE that shipped R10k, you had to be careful to use the version of
the module that didn&rsquo;t ALSO try to upgrade that gem on your system (and whoops
if the module actually upgraded the version of R10k that we shipped). This is
why that module is Puppet Approved but not an offical Puppet Labs module: it
does things that we would consider &ldquo;unsupported&rdquo; outside of a professional
services engagement (i.e. the webhook stuff). Finally, the path to
<code>r10k.yaml</code> was changed to <code>/etc/puppetlabs/r10k/r10k.yaml</code>, but, in its
absence, the old path of <code>/etc/r10k.yaml</code> would be used and a message would
be displayed to inform you of the new file path (in the case that both files
were present, the file at <code>/etc/puppetlabs/r10k/r10k.yaml</code> would win).</p>

<p>When PE version 2015.2.0 shipped (I&rsquo;m still not used to these version numbers
either, folks), we FINALLY shipped a <code>pe_r10k</code> module with similar structure to
Zack&rsquo;s R10k module &ndash; this meant you could FINALLY setup R10k immediatly without
having to install additional Puppet modules. Even better(er), in PE 2015.2.2 we
expose <a href="http://docs.puppetlabs.com/pe/latest/r10k_config_answers.html">a couple of PE installer answer file questions</a> that allow
you to configure R10k DURING INSTALL TIME &ndash; so now your servers could be
immediately bootstrapped with a single answers file (seriously, I know, it&rsquo;s
about time; I do this shit every week, you have no idea). It finally feels like
R10k has grown into the first-class citizen we all wanted it to be!</p>

<p>Which means it&rsquo;s time to dump it.</p>

<p>I kid. Mostly. The fact of the matter is that we&rsquo;re introducing a new service
to manage code within Puppet Enterprise, <a href="https://puppetlabs.com/blog/managing-infrastructure-as-code-now-easier-than-ever">and if you&rsquo;re interested in reading more about it, check out this blog post by Lindsay Smith about Code Manager.</a>
For you, the consumer, the process will be the same: you have a control
repo, you push changes, a service is triggered on your Puppet masters, and code
is synchronized on the Puppet master. What WILL change is the setup of this tool
(there will still be PE installer answer file questions that allow you to configure
this service, don&rsquo;t fret, and you&rsquo;ll still be able to configure this service through
a Puppet module, but the name of said module and configuration files on disk
will probably be different. Welcome to IT).</p>

<p>Be on the lookout for this service, and, as always, check out the <a href="http://docs.puppetlabs.com">PE docs site</a> for
more information on the Code Management service.</p>

<h2>Control (repo) freak</h2>

<p>With the explosion of R10k came the explosion of &ldquo;Control Repos&rdquo; all over the place.
Everyone had one, everyone had an opinion on what worked best, and, well, we didn&rsquo;t
really do a good job at offering a good startup control repo for you. Because of
that, <a href="https://github.com/puppetlabs/control-repo">we recently posted a &lsquo;starter&rsquo; control repo on Github</a> in the Puppet Labs
namespace that could be used to get started with R10k. Yes, it&rsquo;s definitely long
overdue, but there it is! I use it on all engagements I do with new customers, so
you can guarantee it&rsquo;ll have the use of Puppet Labs' PS team behind it. If you&rsquo;ve
not started with R10k yet (or if you have but you wanna see what kinda crazy shit
we&rsquo;re doing now), check it out. It&rsquo;s got great stuff in there like a config_version
script to spit out the most recent commit of the current branch of the control repo
(read: also current Puppet environment) as the &ldquo;Config Version&rdquo; string that Puppet
prints out during every Puppet run (<a href="https://docs.puppetlabs.com/puppet/latest/reference/config_file_environment.html#configversion">see here for more info on this functionality</a>).
We&rsquo;re also slowly adding things like inital bootstrapping profiles that will do
things like configure R10k/Code Manager, manage the SSH key necessary to contact
the control repo (should you be using an internal git repository server and
also require an SSH key to access that repo), and so on. Star that repo and keep
checking back, especially around PE releases, to see if we&rsquo;ve updated things in
a way that will help you out!</p>

<h2>&ldquo;Just put it in the control repo&rdquo;</h2>

<p>Look, if there&rsquo;s one thing that my blog emphasizes (other than the fact that I&rsquo;ve
got a hairpin trigger for cursing and an uncomfortable Harry Potter fetish) it&rsquo;s
that &ldquo;best practices&rdquo; are inversely related to the insecurities of the speaker.
Fortunately, I have no problem saying when I&rsquo;m wrong. If you&rsquo;ve got the time,
allow me my mea culpa moment. In the past I had recommended:</p>

<ul>
<li>Using a separate git repo for Hiera data</li>
<li>Using separate git repos for Roles and Profiles</li>
<li>The Dave Matthews Band</li>
</ul>


<p>Time, experience, and the legalization of recreational marijuana in Oregon have
helped me see the error in my ways (though, look, #41 is a good goddamn song,
especially on the Dave &amp; Tim Live at Luther College album), so allow me to provide
some insight into WHY I&rsquo;ve reconsidered my message(s)&hellip;</p>

<h3>Hiera Data</h3>

<p>In the past, I recommended a separate git repo for Hiera data along with
a separate entry in <code>r10k.yaml</code> that would allow R10k to clone the Hiera data repo
along the same vein as the control repo. The pro was that a separate Hiera data
repo would afford you different access rights to this repo as you would the
control repo (especially if different people needed different access to each
function). The con was that now the branch structure of your Hiera data repo
needed to EXACTLY MIRROR the structure of your control repo&hellip;.even if certain
branches had EXACTLY THE SAME Hiera data and no changes were necessary.</p>

<p>Puppet has enough moving parts, why did we need to complicate this if most
people didn&rsquo;t care about access levels differing between the two repos? The
solution was to bundle the Hiera data inside the control repo all the way up
until you had a specific need to split it out. Truth be told both methods
work with Puppet, so the choice is up to you (read: I DON&rsquo;T CARE WHICH METHOD
YOU USE OH MY GOD WILL YOU QUIT TRYING TO PICK A FIGHT WITH ME OVER THIS LOL) :)</p>

<p>Finally, there&rsquo;s an added benefit of putting this data inside the control repo,
and it&rsquo;s ALSO the reason for the next recommendation&hellip;</p>

<h3>Roles and Profiles</h3>

<p>This is one that I actually fought when someone suggested it&hellip;I even started to
recommend that a customer NOT do the thing I&rsquo;m about to recommend to you until they
very eloquently explained why they did it. In the end, they were right, and I&rsquo;m
passing this tip on to you:  Unless you have a very specific reason NOT to,
put your &lsquo;roles&rsquo; and &lsquo;profiles&rsquo; modules in your control repo.</p>

<p>Here&rsquo;s the thing about the control repo &ndash; you can set a post-receive hook on
the repository (or setup a Jenkins/Bamboo/whatever job) that will update all your
Puppet masters whenever changes are pushed to the remote git repository (i.e.
your git repository server). This means that anytime the control repo is updated
your Puppet masters will be updated. That&rsquo;s why it&rsquo;s CALLED the control repo &ndash; it
effectively CONTROLS your Puppet masters.</p>

<p>Understanding THAT, think about when you want your Puppet masters updated? Well,
you usually want to update them when you&rsquo;re testing something out &ndash; you made a
change to a couple of modules, then a profile (and possibly also a role), and
now you wanna see if that code works on more than just your local laptop.
But the Puppet landscape has changed a bit as the Puppet Forge has matured &ndash; most
people are using modules off the Forge and are at least TRYING not to use their
own component modules. This means that changes to your infrastructure are being
controlled from within roles/profiles. But even IF you&rsquo;re one of those people
who aren&rsquo;t using the Forge or who have to update an internal component module,
you&rsquo;re probably not wanting to update all your Puppet masters every time you
update a component module. There&rsquo;s probably lots of tinkering there, and every
change isn&rsquo;t &ldquo;update-worthy&rdquo;. Conversely, changes to your profiles probably
ARE &ldquo;update-worthy&rdquo;: &ldquo;Okay, let&rsquo;s pull this bit from Hiera, pass it as a parameter,
and now I&rsquo;m ready to check it out on a couple of machines.&rdquo;</p>

<p>If your roles and profiles modules are separate from your control repo, you
end up having to push changes to, say, a class in the profiles module, then
updating the Puppetfile in the control repo, then trigger an R10k run/sync.
If things aren&rsquo;t correct, you end up changing the profile, pushing that change
to the profile repo, and THEN having to trigger an R10k run/sync (and if you
don&rsquo;t have SSH access to your masters, you have to make a dummy commit to the
control repo so it triggers an R10k run OR doing a curl to some endpoint that
will update your Puppet master for you). That last step is the thing that ends
up wasting a bit of your time: why do we need to push a profile and then manually
do an R10k run of we&rsquo;ve established that roles and profiles will pretty much
ALWAYS be &ldquo;update-worthy&rdquo;? We don&rsquo;t. If you put the roles and profiles module
inside the control repo, then it will automatically update your Puppet masters
every time you make a change to one or the other. Bam &ndash; step saved. ALSO, if
you do this, you can take Roles/Profiles out of Puppetfile, which means you
no longer need to pin them! No more will you have to tie that module to a topic
branch during development time: just create a branch of the control repo and
go to town!  Wow, that saves even more time! I&rsquo;m uncomfortable with this level
of excitement!</p>

<p>The one thing you WILL need to do is to update <code>environment.conf</code> so that it
knows to look for the roles/profiles modules in a different path from all the
other modules (because removing it from Puppetfile means that it will no longer
go to the same modulepath as every other module managed inside Puppetfile).
For the purposes of cleanliness, we usually end up putting both roles/profiles
inside a <code>site</code> folder in the control repo. If you do that, your modulepath
in <code>environment.conf</code> looks a little something like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>modulepath = site:modules:$basemodulepath</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This means that Puppet will look for modules first in the &lsquo;site&rsquo; directory of
its current environment (this is the directory where we put roles/profiles),
and then inside the &lsquo;modules&rsquo; directory (this is where modules managed in Puppetfile
are cloned by default), and then in $basemodulepath (i.e. modules common to all
environments and also modules that Puppet Enterprise ships).</p>

<p>LOOK, BEFORE YOU FREAK OUT, YES, SITE COMES FIRST HERE, AND OTHER PEOPLE HAVE
SITE COME SECOND! Basically, if you have roles/profiles in the &lsquo;site&rsquo; directory
AND you manage to still have the module in Puppetfile, then the module in the &lsquo;site&rsquo;
directory will win. Feel free to flip/flop that if you want.</p>

<p><strong>TL;AR: (yes, you already read all of this so it&rsquo;s futile) put roles/profiles
inside the site directory of the control repo to save you time, but also don&rsquo;t
do it if you have a specific reason not to&hellip;or if you like being contrarian.</strong></p>

<h3>Dave Matthews</h3>

<p>The &ldquo;Everyday&rdquo; album was the &ldquo;jump the shark&rdquo; moment for the Dave Matthews band,
while the leaked &ldquo;Lillywhite Sessions&rdquo; that would largely make it to &ldquo;Busted Stuff&rdquo;
definitely indicated where the band wanted to go. They never recovered after that,
and, just like Boone&rsquo;s Farm &lsquo;wine&rsquo;, I stopped partaking in them.</p>

<p>Also, not ONCE did being able to play most every Dave Matthews song on the
acoustic guitar ever get me laid&hellip;though I can&rsquo;t tell exactly whose fault that
was. On second thought, that was probably me. Though Tim Reynolds is an absolute
beast of a musician; I&rsquo;m still #teamtim.</p>

<h2>One role per node, until you don&rsquo;t want to</h2>

<p>Why do we even make these rules if you&rsquo;re not gonna follow them? It&rsquo;s getting
awfully &ldquo;Who&rsquo;s Line Is It Anyways?&rdquo; up in here. Before PE 3.7, and its
rules-based classification engine, we recommended not assigning more than one
role to a node.  Why? Well, the Puppet Enterprise Console around that time
wasn&rsquo;t the best at tracking changes or providing authentication around tasks
like classification.  This meant if you tried to manage ALL of your
classification within the console you could have a hard time telling when
things changed or why. Fortunately, git provides you with this functionality.
Because of that, we (and when I say &lsquo;we&rsquo; I mean &lsquo;everyone in the field trying
to design a Puppet workflow that not only made sense but also had some level of
accountability&rsquo;) tried to displace most classification tasks from the Console
into flat files that could be managed with git. This is largely the impetus for
Roles and Profiles when you think about it: Profiles connect Puppet to external
ata and give you a layer to express dependencies between multiple Puppet
classes, and Roles is a mechanism for boiling down classification to a single
unit.</p>

<p>Once we launched a new Node Classifier that had a rules-based classification
engine AND role-based authentication control, we became more comfortable
delegating some of these classification tasks BACK to the console. The Node
Classifier ALSO made it easy to click on a node and not only see what was
classified to that node, but also WHERE it got that bit of classification
from (&ldquo;This node is getting the JBoss profile because it was put into the
App Servers nodegroup&rdquo;). With that level of accountability, we could start
relaxing our &ldquo;One Role Per Nodeâ„¢&rdquo; mandate, OR eliminate the roles module
altogether (and use nodegroups in the Node Classifier in place of roles).</p>

<p>The goal has always been to err on the side of &ldquo;debugability&rdquo; (I like making words).
I will usually try to optimize a task for tracing errors later, because I&rsquo;ve been
a sysadmin where the world is falling apart around you and you need to quickly
determine what caused this mess. Using one role per node makes sense if you
don&rsquo;t use a node classifier that gives you this flexibility, but MIGHT not if
you DO use a classifier that has some level of accountability.</p>

<h2>Roles, conditional logic, Hiera, and you</h2>

<p>Over time as I&rsquo;ve talked to people that ended up building Puppet workflows
based on the things I&rsquo;ve written (which still feels batshit crazy to me,
by the way, since I&rsquo;ve known myself for over 34 years), I&rsquo;ve noticed that people
seem to take the things I say VERY LITERALLY. And to this I say: &ldquo;You should
probably send me money via Paypal.&rdquo; Also &ndash; note that I&rsquo;m writing these things
to address the 80% of people out there using/getting started with Puppet. You
don&rsquo;t HAVE to do what I say, especially if you have a good reason not to, and
you SHOULDN&rsquo;T do what I say, especially if you&rsquo;re the one that&rsquo;s going to stay
with that organization forever and manage the entire Puppet deployment. For
everyone else out there, let&rsquo;s talk some more about roles.</p>

<p>The talking points around roles has always been &ldquo;Roles include profiles; that&rsquo;s it.&rdquo;
Again, going back to the idea that roles exist to support classification, this
makes sense &ndash; you don&rsquo;t want to add resources at a very high level like a roles
class because, well, honestly, there&rsquo;s probably a better place for it, but any
logic added to simply classification is a win.</p>

<p>Consider an organization that has both Windows and Linux application servers.
The question of whether to have separate roles for Linux and Windows
application servers is always one of the first questions to be surfaced. At
a low level, everything you do in a Puppet manifest is solely for the
purpose of getting resources into the catalog (a JSON object containing
a list of all resource Puppet is to be managing ond their desired end-state).
Whether you have two different roles matters not to Puppet so long as the
right node gets the right catalog. For a Puppet developer writing code, having
two separate roles also might not matter (and, in reality, based on the amount
of code assigned to either role, it might be cleaner to have different roles
for each). For the person in charge of classifying nodes with their assigned
role, it&rsquo;s probably easier to have a single role (<code>roles::application_server</code>, for example)
that can be assigned to ALL application servers, and then logic inside the role
to determine whether this will be a Windows application server using IIS or
a Linux application server using JBoss (or, going further, a Linux application
server running Weblogic, or Websphere, or Tomcat, whatever). Like we mentioned
in the previous point, if you&rsquo;re using the &ldquo;One role per node&rdquo; philosophy, then
you probably want a single role with conditional logic to determine Windows/Linux,
and then determine Tomcat/JBoss, and so on. If you&rsquo;re using the Puppet Enterprise
Console&rsquo;s node classifier, and thus the rule-based engine, you can afford not
to care about the number of node groups you create because you can create a rule
to match for application servers, and then a rule to match on operating system,
and create as many rules as you want to dynamically discover and classify nodes
on the fly.</p>

<p>The point here is that the PURPOSE of the Role is to aid classification, and
the focus on creating a role is to start small, use conditional logic to
determine which profiles to include, and then simply include them. If that
conditional logic uses Facter facts, awesome. If you need to look at a variable
coming from the Console to do the job, fine &ndash; go for it! But if you&rsquo;re using
the Role as a substitute for a Profile (i.e. data lookups, declaring classes,
even declaring resources), then you&rsquo;re probably going down a path that&rsquo;s gonna
make it confusing for people follow what&rsquo;s going on.</p>

<p>Bottom line: technology-agnostic roles that utilize conditional logic around
including profiles is a win, but keep tasks like declaring resources and
component modules to Profiles. Doing this provides a top-down path for
debugging and a cleaner overall Puppet codebase.</p>

<h2>What the hell is &lsquo;Data&rsquo; anyhow?</h2>

<p>This point has single-handedly caused more people to come up and argue with me.
I&rsquo;m not kidding. I shit you not, I&rsquo;ve had people legitimately *SCREAM* at me
about how wrong I was with my opinions here. The cool thing is that people LOVE
the idea of Hiera &ndash; it lets you keep the business-specific data out of your
Puppet manifests, it&rsquo;s expressed in YAML and not the Puppet DSL, and when it
works, it&rsquo;s magical.</p>

<p>The problem is that it&rsquo;s fucking magical. Seriously.</p>

<p>So what IS a good use of Hiera? Anytime you have a bit of data that is subject
to override (for example: the classical NTP problem where everyone should use
the generic company NTP server, except nodes at this location should use a
different NTP server, and this particular node should use ITSELF as its NTP
server), that bit of data goes into Hiera (and by &lsquo;that bit of data&rsquo;, I mean
&lsquo;the value of the NTP server&rsquo; or &lsquo;the NTP server&rsquo;s FQDN&rsquo;), which would look
SOMETHING like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">ntpserver</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">pool.ntp.org</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>What does NOT go into Hiera is a hash-based representation of the Puppet
resource that would then be passed to create_resources() and used to create
the resource in the catalog&hellip;which would look something like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">ntpfiles</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;lsquo</span><span class="l-Scalar-Plain">;/etc/ntp/ntpd.conf&amp;rsquo;:&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;pre&gt;&lt;code&gt;ensure</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">file</span>
</span><span class='line'><span class="l-Scalar-Plain">owner</span><span class="p-Indicator">:</span>  <span class="l-Scalar-Plain">0</span>
</span><span class='line'><span class="l-Scalar-Plain">group</span><span class="p-Indicator">:</span>  <span class="l-Scalar-Plain">0</span>
</span><span class='line'><span class="l-Scalar-Plain">mode</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">0644</span>
</span><span class='line'><span class="l-Scalar-Plain">source</span><span class="p-Indicator">:</span> <span class="s">&#39;puppet:///modules/ntp/ntpd.conf&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>&hellip;which would then be passed into Puppet like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nf">create_resources</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">file</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">,</span> <span class="nf">hiera_hash</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">ntpfiles</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Yes, this is an exaggeration based on a very narrow use case, but what I&rsquo;m trying
to highlight is that the &lsquo;data&rsquo; bit in all that above mess is SOLELY an FQDN,
and everything else is arguably the &ldquo;Model&rdquo;, or your Puppet code.</p>

<p>Organizations LOVE that you can put as much &ldquo;stuff&rdquo; into Hiera as you want and
then Puppet can call Hiera, create resources based on what it tells you, and
merrily be on your way. Well, they &ldquo;love&rdquo; it until it doesn&rsquo;t work or does
something unexpected, and then debugging Hiera is a right bastard.</p>

<p>Understand that the problem I have would be with unexpected Hiera behavior. If
you&rsquo;re skilled in the ways of the Hiera and its (sometimes cloudy) interaction
with Puppet, then by ALL means use it for whatever ya like. BUT, if you&rsquo;re
still new to Puppet, then you may have a very loose mental map for how Hiera
works and where it interacts with Puppet&hellip;and nobody should have to have that
advanced level of knowledge just to debug the damn thing.</p>

<p>The Hiera + create_resources() use above is of particular nastiness simply
because it turns your Hiera YAML files into a potential mechanized weapon of Puppet
destruction.  If I know that you&rsquo;re doing this under the hood, I could
POTENTIALLY slip data into Hiera that would end up creating resources on a node
to do what I want. Frequently Puppet code is more heavily scrutinized than
Hiera data, and I could see something like this getting overlooked (especially
if you don&rsquo;t have a ton of testing around your Puppet code before it gets
deployed).</p>

<p>The REASON why create_resources() was created was because Puppet lacked the
ability to do things like recursion and loops inside the DSL, and sometimes
you WANT to automate very repeated tasks. Consider the case where you truly
DON&rsquo;T know how many of something is going to be on a node ahead of time &ndash; maybe
you&rsquo;re using VMware vRO/vRA and someone is building a node on-the-fly with
the web GUI. For every checkbox someone ticks there will be another application
to be installed, or another series of firewall rules, or SOMETHING like that.
You can choose to model these individually with profiles, OR, if the task is
repetitive, you can accept their choices as data and feed it back into Puppet
like a defined resource type. In fact, most use-cases for Hiera + create_resources()
is passing data into a defined resource type. As of Puppet 4.x.x, we have
looping constructs inside the DSL, so we can finally AUTOMATE these tasks
without having to use an extra function (of course, in THIS use case, whether
you use recursion/looping in the DSL or create_resources() matters not &ndash; you
get the same thing in the end).</p>

<p>For one last point, the Puppet DSL is still pretty easy to read (as of right now),
and most people can follow what&rsquo;s going on even if they&rsquo;re NOT PuppEdumicated.
Having 10 resource declarations in a row seems like a pain in the ass to write
when you&rsquo;re doing it, but READING it makes sense. Later on, if you need to know
what&rsquo;s going on with this profile, you can scan it and see exactly what&rsquo;s there.
If you start slipping lots of data into Hiera and looping logic into the DSL,
you&rsquo;re gonna force the person who manages Puppet to go back and forth between
reading Hiera code, then back to Puppet code, then back to the node, and so on.
Again, it&rsquo;s totally possible to do now, and frequently NECESSARY when you have
a more complex deployment and well-trained Puppet administrators, but initially
it&rsquo;s possible to build your own DSL to Puppet by slipping things into Hiera and
running away laughing.</p>

<p>So when do I put this &lsquo;data&rsquo; into the Profile and when is a good time to put it
into Hiera?  I&rsquo;m glad you asked&hellip;</p>

<h2>A path to Hiera data</h2>

<p>These last two points I&rsquo;ve written about before. I may be repeating myself, but
bytes are cheap. Like I wrote above (and before), putting data directly into a
Profile is the easiest and most legible way of providing &ldquo;external data&rdquo; into
Puppet. Yes, you&rsquo;ll argue, putting the data into a Profile, which is Puppet code,
is ARGUABLY NOT being very &ldquo;external&rdquo; about it. In my opinion it is &ndash; your Profile
is YOUR IMPLEMENTATION of a technology stack, and thus isn&rsquo;t going to be shared
outside your organization. I consider that external to all the component modules
out there, but, again, potato/potato. I recommend STARTING HERE when you&rsquo;re getting
started with Puppet. Hiera comes in when you have a very clear-cut need for
overriding data (a la: this NTP server everywhere, except here and here). The second
you might need to have different data, you can either start building conditional logic
inside the Profile, OR use the conditional logic that Hiera provides.</p>

<p>So &ndash; which do you use?</p>

<p>The point of Hiera is to solve 80% or better of all conditional choices in your
organization. Consider this data organization model:</p>

<ul>
<li>Everyone shares most of the same data items</li>
<li>San Francisco/London do their own things sometimes</li>
<li>Application tiers get their own level for dev/test/qa/prod-specific overrides</li>
<li>Combinations of tiers/locations/and business units want their own overrides</li>
<li>Node specific data is the most specific (and least-used) level</li>
</ul>


<p>If you&rsquo;re providing some data to Puppet that follows this model, then cool
&ndash; use Hiera. What about specific &ldquo;exceptions&rdquo; that don&rsquo;t fit this model? Do you
try to create specialized layers in Hiera just for these exceptions? Certain
organizations absolutely do &ndash; I see it all the time. What you find is that
certain layers in Hiera go together (this location/tier/business_unit level
goes right above location/tier, which goes right above location), and we
start referring to those coupled layers as &ldquo;Chains&rdquo;. Chains are usually tied
to some specific need (deploying applications, for example). Sometimes you
create a chain just to solve a VERY SPECIFIC hard problem (populating
<code>/etc/sudoers</code> in large organizations, for example).</p>

<p>The question is &ndash; do I create another &ldquo;Chain&rdquo; of layers in the hierarchy
solely because deploying <code>sudoers</code> is hard, or do I throw a couple of case
statements into the <code>sudoers</code> profile and keep it out of Hiera altogether?</p>

<p>My answer is to start with conditional logic in the <code>sudoers</code> profile and break
it out into Hiera if you see that &ldquo;Chain&rdquo; being needed elsewhere. Why? Because, like
I&rsquo;ve said many times before, debugging Hiera kinda sucks right now &ndash; there&rsquo;s no
way currently to get a dump of all variables and parameters for a particular node
and determine which were set by Hiera, which were set with variables in the DSL, which
came out of the console, and so on. If we HAD that tool, I&rsquo;d be all about using
it and polluting your hierarchy all day long (I expand upon this slightly in the
next point about the Automatic Parameter Lookup + Hiera).</p>

<p>Bottom line: Start with the data in the Profile, then move it to Hiera when you
need to override. Start with conditional logic in the Profile, then create a
&ldquo;Chain&rdquo; in the Hierarchy if you need to use it in more than one place.</p>

<h2>Hiera, APL, Refactoring, WTF</h2>

<p>Like I said, I&rsquo;ve written about this before. I like the Automatic Parameter
Lookup functionality in Puppet &ndash; it&rsquo;s ace. I like Hiera. But if you don&rsquo;t know
how it works, or that it exists, it feels too much like Magic. There are certain
things in the product that can ONLY be set by putting data inside Hiera and running
Puppet, and that is truly an awesome thing: just tell a customer &ldquo;drop this bit
of data somewhere in Hiera, run Puppet, and you&rsquo;re all set.&rdquo; But, again, if you
need to know how a particular line got into a particular config file on your
node, and it was set with the APL, then you&rsquo;ve got some digging to do.</p>

<p>There&rsquo;s still no tool, like I mentioned in the last item, to give me full
introspection into all variables/parameters set for a node and that
variable/parameter&rsquo;s origin.  Part of the reason as to WHY this tool doesn&rsquo;t
exist is because the internals of Puppet don&rsquo;t necessarily make it easy for you
to determine where a parameter/variable was set.  That&rsquo;s OUR problem, and
I feel like we&rsquo;re slowly making progress on marking these things internally so
we can expose them to our customers. Until then, you have to trace through code
and Hiera data.</p>

<p>I know the second I publish and tweet about this, I&rsquo;m gonna get a message from
R.I. Pienaar saying that I&rsquo;ve crazy for NOT pushing people toward using Hiera
more with the Automatic Parameter Lookup, because the more we use it, the faster
we can move away from things like params classes, and profiles, and everything
else, but the reality is I&rsquo;m ALL ABOUT PEOPLE using it if they know how it works.
I&rsquo;m ACTUALLY fucking happy that it works well for you &ndash; please continue to use
it and do awesome Puppet things. I only recommend to people who are getting
started to NOT USE it FIRST, and then, when you understand how it would help
you by clocking some hours of Puppet code writing and debugging, do some refactoring
and move to it!</p>

<p>Yes, refactoring is involved.</p>

<p>Look, refactoring is a way of life. You&rsquo;re gonna re-tool your Puppet code for
the purposes of legibility, or efficiency, or any of the many other reasons why
you refactor code &ndash; it&rsquo;s unavoidable. Also, if I come into your org and setup
Puppet for the most efficient use-case, and then I leave that into your
relatively-new-to-Puppet hands, it&rsquo;s probably not gonna be the best situation
because you won&rsquo;t have known WHY I made the decisions I did (and, even if I
document them, you might have gaps of knowledge that would help you understand
the problems I&rsquo;m helping you avoid).</p>

<p>Sometimes hitting the problem so you have first-hand knowledge of why you need
to avoid it in the future isn&rsquo;t the WORST thing in the world.</p>

<p>To move to any configuration management system means you&rsquo;re gonna be
refactoring.  Embrace it. Start small, get things working, then clean it up.
Don&rsquo;t try to build the &ldquo;fortress of sysadmin perfection&rdquo; with your first bit of
Puppet code &ndash; just get shit done! Allow yourself time during the month simply
to unwind some misgivings you realize after-the fact, and definitely seek
advice before doing something you feel might be particularly complex or
overarching, but getting shit done is gonna trump &ldquo;not working&rdquo; any day (or
whatever the manager-y buzzspeak is this week).</p>

<p>Bottom Line: APL if you understand it, start small, get shit done, refactor, repeat</p>

<h2>Hopefully this leads to more posts</h2>

<p>Holy shit, you&rsquo;re still reading?! Ohh, you skimmed down this far to see how long
this post was gonna be &ndash; got it. Either way, I&rsquo;m glad I finally got this out there.
It&rsquo;s been months, yes, but that doesn&rsquo;t mean I haven&rsquo;t been writing. We&rsquo;ve been
doing lots of internal work to try and get more official docs out to you and
less of &ldquo;Go read Gary&rsquo;s blog!&rdquo; You&rsquo;ll notice <a href="http://docs.puppetlabs.com/pe/latest/r10k.html">R10k has some official docs, right?!</a>
Yeah, that&rsquo;s awesome! We want more of that. BUT, there&rsquo;s still going to be times
where I feel like what I&rsquo;m gonna say isn&rsquo;t necessarily the &ldquo;party line&rdquo;, and that&rsquo;s
what this blog is about.</p>

<p>Thanks to everyone at Puppetconf and beyond who approached me and told me how
much they love what I write. I&rsquo;m gonna be humble as fuck in person, but I really
do get excited whenever someone says that. It&rsquo;s also crazy as hell when someone
from Wal-mart approaches you and says they built part of their deployment based
on the shit you wrote. From a guy who came from a town in Ohio with a population
of less than 8000 people, it&rsquo;s crazy to see where you&rsquo;re &ldquo;recognized.&rdquo;</p>

<p>So thank you, again, for all the support.</p>

<p>And sorry, Dave Matthews &ndash; it&rsquo;s not you, it&rsquo;s me. Actually, that&rsquo;s a lie; it was you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puppet Workflows 4: Using Hiera in anger]]></title>
    <link href="http://garylarizza.com/blog/2014/10/24/puppet-workflows-4-using-hiera-in-anger/"/>
    <updated>2014-10-24T08:13:49-05:00</updated>
    <id>http://garylarizza.com/blog/2014/10/24/puppet-workflows-4-using-hiera-in-anger</id>
    <content type="html"><![CDATA[<p>Hiera. That thing nobody is REALLY quite sure how to say (FYI: It&rsquo;s pronounced
&lsquo;hiera&rsquo;), the tool that everyone says you should be using, and the tool that
will make you hate YAML syntax errors with a passion. It&rsquo;s a data/code
separation dream, (potentially) a debugging nightmare, and absolutely vital in
creating a Puppet workflow that scales better than your company&rsquo;s Wifi strategy
(FYI: your company&rsquo;s Wifi password just changed. Again. Because they&rsquo;re not
using certificates). I&rsquo;ve already written a GOOD AMOUNT on why/how to use it,
but now I&rsquo;m going to give you a couple of edge cases. Call them &ldquo;best
practices&rdquo; (and I&rsquo;ll cut you), but I like to call it &ldquo;shit I learned
after using Hiera in anger.&rdquo; Here are a couple of the most popular questions
I hear, and my usual responses&hellip;</p>

<h2>&ldquo;How should I setup my hierarchy?&rdquo;</h2>

<p>This is such a subjective question because it&rsquo;s specific to your organization
(because it&rsquo;s your data). I usually ask back &ldquo;What are the things about your
nodes that are different, and when are they different?&rdquo; Usually I hear something
back like &ldquo;Well, nodes in this datacenter have different DNS settings&rdquo; or
&ldquo;Application servers in production use one version of java, and those in dev
use a different version&rdquo; or &ldquo;All machines in the dev environment in this datacenter
need to have a specific repository&rdquo;. All of these replies give me ideas to your
hierarchy.  When you think of Hiera as a giant conditional statment, you can
start seeing how your hierarchy could be laid out.  With the first response, we
know we need a <code>location</code> fact to determine where a node is, and then we can
have a hierarchy level for that location. The second response tells me we need
a level for the application tier (i.e. dev/test/prod).  The third response tells
me we need a level that combines both the location and the application tier. When
you add in that you should probably have a node-specific level at the top (for
overrides) and a default level at the bottom (or not: see the next section), I&rsquo;m
starting to picture this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">:hierarchy</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; &amp;ldquo;nodes/%{::clientcert}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;%{::location}/%{::applicationtier}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;%{::location}/common&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;tier/%{::applicationtier}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; common</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Every time you have a need, you consider a level.  Now, obviously, it doesn&rsquo;t
mean that you NEED a level for every request (sometimes if it&rsquo;s an edge case
you can handle it in the profile or the role). There&rsquo;s a performance hit for
every level of your Hiera hierarchy, so ideally keep it minimal (or around
5 levels or so), but we&rsquo;re talking about flexibility here, and, if that&rsquo;s more
important than performance then you should go for it.</p>

<p>Next comes ordering. This one&rsquo;s SLIGHTLY easier &ndash; your hierarchy should read from
most-specific to least-specific. Note that when you specify an application tier
at a specific location that that it is MORE specific than just saying &ldquo;all nodes in
this application tier.&rdquo; Sometimes you will have levels that might be hard to
define an order &ndash; such as location vs. application tier. You kinda just have to
go with your gut here. In many cases you may find that the data you put in those
two levels will be entirely different (location-based data may not ever overlap
with application-tier-specific data). Do remember than any time you change the
order of your hierarchy you&rsquo;re going to introduce the possibility that values
get flip/flopped.</p>

<p>If you look at level 3 of the hierarchy above, you&rsquo;ll see that I have &lsquo;common&rsquo;
at the end. Some people like this syntax (where they put a &lsquo;common&rsquo; file in a
folder that matches the fact they&rsquo;re checking against), and some people prefer
a filename matching the fact.  Do what makes you happy, but, in this case,
we can unify the location folder and just put the common file underneath the
application tier files.</p>

<p>Finally, DO MAKE USE OF FOLDERS!  For the love of god, this. Putting all files
in a single folder both makes that a BIG folder, but also introduces a namespace
collision (i.e. what if you have a location named &lsquo;dev&rsquo; for example? Now you have
both an application tier and a location with the same name.  Oops).</p>

<p>How you setup your hierarchy is up to you, but this should hopefully give you
somewhere to start.</p>

<h2>Common.yaml, your organization&rsquo;s common values &ndash; <strong>REVISED</strong></h2>

<p><strong>UPDATE &ndash; 28 October</strong></p>

<p><em>Previously, this section was where I presented the idea of removing the lowest
level of the hierarchy as a way of ensuring that you didn&rsquo;t omit a value in Hiera
(the idea being that common values would be in the profile, anything higher would
be in Hiera, and all your &lsquo;defaults&rsquo;, or &lsquo;common values&rsquo; would be inside the profile).
The idea of removing the lowest level of the Hiera hierarchy was always something
I was kicking around in my head, but R.I. made a comment below that&rsquo;s made me revise
my thought process. There&rsquo;s still a greater concern around definitively tracking
down values pulled from Hiera, but I think we can accomplish that through other
means. I&rsquo;m going to revise what I wrote below to point out the relevant details.</em></p>

<p>When using Hiera, you need to define a hierarchy that Hiera uses in its search
for your data. Most often, it looks something like this:</p>

<h2><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>hiera.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">&lt;/h2&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;p&gt;:backends</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; yaml</span>
</span><span class='line'><span class="l-Scalar-Plain">:yaml</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">:datadir</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/etc/puppetlabs/puppet/hieradata</span>
</span><span class='line'><span class="l-Scalar-Plain">:hierarchy</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; &amp;ldquo;nodes/%{::clientcert}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;location/%{::location}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; &amp;ldquo;environment/%{::applicationtier}&amp;rdquo;</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; common</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Notice that little &ldquo;common&rdquo; at the end?  That means that, failing everything
else, it&rsquo;s going to look in <code>common.yaml</code> for a value. I had thought of common
as the &lsquo;defaults&rsquo; level, but the reality is that it is a list of values common
across all the nodes in your infrastructure.  These are the values, SPECIFIC TO
YOUR ORGANIZATION, that should be the same everywhere. Barring an override at a
higher level, these values are your organization&rsquo;s &lsquo;defaults&rsquo;, if you will.</p>

<p>Previously, you may have heard me rail against Hiera&rsquo;s optional second argument
and how I really don&rsquo;t like it.  Take this example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nv">$foo</span> <span class="o">=</span> <span class="nf">hiera</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">port</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">,</span> <span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="m">80</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Given this code, Hiera is going to look for a parameter called &lsquo;port&rsquo; in its
hierarchy, and, if it doesn&rsquo;t find one in ANY of the levels, assign back a default
value of &lsquo;80&rsquo;.  I don&rsquo;t like using this second argument because:</p>

<ol>
<li>If you forget to enter the &lsquo;port&rsquo; parameter into the hierarchy, or typo it in the YAML file, Hiera will gladly assign the default value of &lsquo;80&rsquo; (which, unless you&rsquo;re checking for this, might sneak and get into production)</li>
<li>Where is the real &lsquo;default&rsquo; value: the value in <code>common.yaml</code> or the optional second argument?</li>
</ol>


<p>It actually depends on where you do the hiera() call as to what &lsquo;kind&rsquo; of
default value this is. Note that previously we talked about how the &lsquo;common&rsquo;
level represented values common across your infrastructure. If you do this
hiera() call inside a profile (which is where I recommend it be done), providing
the optional second argument ends up being redundant (i.e. the value should be
inside Hiera).</p>

<p>The moral of this story being: values common to all nodes should be in the
lowest level of the Hiera hierarchy, and all explicit hiera calls should
omit the default second argument if that common value is expected to be found
in the hierarchy.</p>

<h2>Data Bindings</h2>

<p>In Puppet 3, we introduced the concept of &lsquo;data bindings&rsquo; for parameterized classes,
which meant that Puppet now had another choice for gathering parmeter values.
Previously, the order Puppet would look to assign a value for parameters to
classes was:</p>

<ol>
<li>A value passed to the class via the parameterized class syntax</li>
<li>A default value provided by the class</li>
</ol>


<p>As of Puppet 3, this is the new parameter assignment order:</p>

<ol>
<li>A value passed to the class via the parameterized class syntax</li>
<li>A Hiera lookup for <em>classname::parametername</em></li>
<li>A default value provided by the class</li>
</ol>


<p>Data bindings is meant to be pluggable to allow for ANY data backend, but,
as of this writing, there&rsquo;s currently only one: Hiera.  Because of this,
Puppet will now automatically do a Hiera lookup for every parameter to a
parameterized class that isn&rsquo;t explicitly passed a value via the parameterized
class syntax (which means that if you just do <code>include classname</code>, Puppet
will do a Hiera lookup for EVERY parameter defined to the &ldquo;classname&rdquo; class).</p>

<p>This is really cool because it means that you can just add <em>classname::parametername</em>
to your Hiera setup, and, as long as you&rsquo;re not EXPLICITLY passing that
parameter&rsquo;s value to the class, Puppet will do a lookup and find the value.</p>

<p>It&rsquo;s also completely transparent to you unless you know it&rsquo;s happening.</p>

<p>The issue here is that this is new functionality to Puppet, and it feels like
magic to me. You can make the argument and say &ldquo;If you don&rsquo;t start using it,
Gary, people will never take to it,&rdquo; however I feel like this kind of magical
lookup in the background is always going to be a bad thing.</p>

<p>There&rsquo;s also another problem.  Consider a Hiera hierarchy that has 15 levels
(they exist, TRUST ME).  What happens if you don&rsquo;t define ANY parameters in
Hiera in the form of <em>classname::parametername</em> and simply want to rely on
the default values for every class?  Well, it means that Hiera is STILL going
to be triggered for every parameter to a class that isn&rsquo;t explicitly passed a
value.  That&rsquo;s a hell of a performance hit.  Fortunately, there&rsquo;s a way to
disable this lookup.  Simply add the following to the Puppet master&rsquo;s <code>puppet.conf</code>
file:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>data_binding_terminus = none</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It&rsquo;s going to be up to how your team needs to work as to whether you use Hiera
data bindings or not. If you have a savvy team that feels they can debug these
lookups, then cool &ndash; use the hell out of it. I prefer to err on the side of an
explicit hiera() lookup for every value I&rsquo;m querying, even if it&rsquo;s a lot of extra
lines of code. I prefer the visibility, especially for new members to your team.
For those people with large hierarchies, you may want to weigh the performance
hit.  Try to disable data bindings and see if your master is more performant. If
so, then explicit hiera() calls may actually buy you some rewards.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Adding parameters to Hiera in the style of <em>classname::parametername</em> will set parameterized class values automatically</li>
<li>Simplified code &ndash; simply use the include() function everywhere (which is safer than the parameterized class syntax)</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Lookup is completely transparent unless you know what&rsquo;s going on</li>
<li>Debugging parameter values can be difficult (especially with typos or forgetting to set values in Hiera)</li>
<li>Performance hit for values you want to be assigned the class default value</li>
</ul>


<h2>Where to data &ndash; Hiera or Profile?</h2>

<p>&ldquo;Does this go right into the Profile or into Hiera?&rdquo;  I get that question
repeatedly when I&rsquo;m working with customers. It&rsquo;s a good question, and one of
the quickest ways to blow up your YAML files in Hiera. Here&rsquo;s the order I use
when deciding where to put data:</p>

<h3>WHERE did that data come from?</h3>

<p>Remember that the profile is YOUR implementation &ndash; it describes how YOU define
the implementation of a piece of technology in YOUR organization. As such, it&rsquo;s
less about Puppet code and more about pulling data and passing it TO the Puppet
code. It&rsquo;s the glue-code that grabs the data and wires it up to the model that
uses it. How it grabs the data is not really a big deal, so long as it grabs
the RIGHT data &ndash; right? You can choose to hardcode it into the Profile, or use
Hiera, or use some other magical data lookup mechanism &ndash; we don&rsquo;t really care
(so long as the Profile gathers the data and passes it to the correct Puppet
class).</p>

<p>The PROBLEM here is debugging WHERE the data came from. As I said previously,
Hiera has a level for all bits of data common to your organization, and, obviously,
data overridden at a higher level takes precedence over the &lsquo;common&rsquo; level at
the bottom. With Hiera, unless you run the <code>hiera</code> binary in debug mode (-d),
you can never be completely sure where the data came from. Puppet has no way of
dumping out every variable and where it came from (whether Hiera or set directly
in the DSL, and, if it WAS Hiera, exactly what level or file it came from).</p>

<p>It is THIS REASON that causes me to eschew things like data bindings in Puppet.
Debugging where a value came from can be a real pain in the ass. If there were
amazing tooling around this, I would 100% support using data bindings and just
setting everything inside Hiera and using the include() function, but, alas,
that&rsquo;s not been my experience. Until then, I will continue to recommend explicit
<code>hiera</code> calls for visibility into when Hiera is being called and when values
are being set inside the DSL.</p>

<h3>Enter the data into the Profile</h3>

<p>One of the first choices people make is to enter the data (like ntpserver
address, java version, or whatever it is) directly into the Profile.
&ldquo;BUT GARY! IT&rsquo;S GOING TO MAKE IT HARD TO DEBUG!&rdquo;  Not really. You&rsquo;re going to
have to open the Profile anyway to see what&rsquo;s going on (whether you pull the
data from Hiera or hardcode it in the Profile), right? And, arguably, the
Profile is legible&hellip;doing Hiera lookups gives you flexibility at a cost of
abstracting away how it got that bit of data (i.e. &ldquo;It used Hiera&rdquo;). For newer
users of Puppet, having the data in the Profile is easier to follow. So, in the
end, putting the data into the Profile itself is the least-flexible and most-visible
option&hellip;so consequently people consider it as the first available option. This option
is good for common/default values, BUT, if you eventually want to use Hiera, you need
to re-enter the data into the common level of Hiera. It also splits up your
&ldquo;source of truth&rdquo; to include BOTH the Profile manifest and Hiera. In the end,
you need to weigh your team&rsquo;s goals, who has access to the Hiera repo, and
how flexible you need to be with your data.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Data is clearly visible and legible in the profile (no need to open additional files)</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Inability to redefine variables in Puppet DSL makes any settings constants by default (i.e. no overriding permitted)</li>
<li>Data outside of Hiera creates a second &ldquo;source of truth&rdquo;</li>
</ul>


<h3>Enter the data into Hiera</h3>

<p>If you find that you need to have different bits of data for different nodes
(i.e. a different version of Java in the dev tier instead of the prod tier),
then you can look to put the data into Hiera.  Where to put the data is going
to depend on your own needs &ndash; I&rsquo;m trusting that you can figure this part out &ndash; but
the bigger piece here is that once the data is in Hiera you need to ensure
you&rsquo;re getting the RIGHT data (i.e. if it&rsquo;s overridden at a higher level, you
are certain you entered it into the right file and didn&rsquo;t typo anything).</p>

<p>This answers that &ldquo;where&rdquo; question, but doesn&rsquo;t answer the &ldquo;what&rdquo; question&hellip;as
in &ldquo;What data should I put into Hiera?&rdquo;  For that, we have another section&hellip;</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Flexibility in returning different values based on different conditions</li>
<li>All the data is inside one &lsquo;source of truth&rsquo; for data according to your organization</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Visibility &ndash; you must do a Hiera lookup to find the value (or open Hiera&rsquo;s YAML files)</li>
</ul>


<h2>&ldquo;What exactly goes into Hiera?&rdquo;</h2>

<p>If there were one question that, if answered incorrectly, could make or break
your Puppet deployment, this would be it. The greatest strength and weakness of
Hiera is its flexibility.  You can truly put almost anything in Hiera, and, when
combined with something like the create_resources() function, you can create
your own YAML configuration language (tip: don&rsquo;t actually do this).</p>

<p>&ldquo;But, seriously, what should go into Hiera, and what shouldn&rsquo;t?&rdquo;</p>

<p>The important thing to consider here is the price you pay by putting data into
Hiera. You&rsquo;re gaining flexibility at a cost of visibility.  This means that you
can do things like enter values at all level of the hierarchy that can be
concatenated together with a single hiera_array() call, BUT, you&rsquo;re losing the
visibility of having the data right in front of you (i.e. you need to open up
all the YAML files individually, or use the <code>hiera</code> binary to debug how you got
those values). Hiera is REALLY COOL until you have to debug why it grabbed (or
DIDN&rsquo;T grab) a particular value.</p>

<p>Here&rsquo;s what I usually tell people about what should be put into Hiera:</p>

<ul>
<li>The exact data values that need to be different conditionally (i.e. a different ntp server for different sites, different java versions in dev/prod, a password hash, etc.)</li>
<li>Dynamic data expressed in multiple levels of the hierarchy (i.e. a lookup for &lsquo;packages&rsquo; that returns back an array of all the values that were found in all the levels of the hierarchy)</li>
<li>Resources as a hash ONLY WHEN ABSOLUTELY NECESSARY</li>
</ul>


<h3>Puppet manifest vs. create_resources()</h3>

<p>Bullets 1 and 2 above should be pretty straightforward &ndash; you either need to use
Hiera to grab a specific value or return back a list of ALL the values from ALL
the levels of the hierarchy. The point here is that Hiera should be returning
back only the minimal amount of data that is necessary (i.e. instead of
returning back a hash that contains the title of the resource, all the attributes
of the resource, and all the attribute values for that resource, just return
back a specific value that will be assigned to an attribute&hellip;like the password
hash itself for a user). This data lookup appears to be &ldquo;magic&rdquo; to new users of
Puppet &ndash; all they see is the magic phrase of &ldquo;hiera&rdquo; and a parameter to search
for &ndash; and so it becomes slightly confusing. It IS, however, easier to understand
that this magical phrase will return data, and that that data is going to be used
to set the value for an attribute. Consider this example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nv">$password</span> <span class="o">=</span> <span class="nf">hiera</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">garypassword</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span><span class="o">&lt;</span><span class="err">/</span><span class="ss">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="ss">p</span><span class="o">&gt;</span><span class="ss">user</span> <span class="err">{</span> <span class="err">&amp;lsquo;gary&amp;rsquo;:</span>
</span><span class='line'>  <span class="err">ensure</span>   <span class="err">=&gt;</span> <span class="err">present,</span>
</span><span class='line'>  <span class="err">uid</span>      <span class="err">=&gt;</span> <span class="err">&amp;lsquo;5001&amp;rsquo;,</span>
</span><span class='line'>  <span class="err">gid</span>      <span class="err">=&gt;</span> <span class="err">&amp;lsquo;gary&amp;rsquo;,</span>
</span><span class='line'>  <span class="err">shell</span>    <span class="err">=&gt;</span> <span class="err">&amp;lsquo;zsh&amp;rsquo;,</span>
</span><span class='line'>  <span class="err">password</span> <span class="err">=&gt;</span> <span class="nv">$password</span><span class="err">,</span>
</span><span class='line'><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This leads us to bullet 3, which is &ldquo;the Hiera + create_resources() solution.&rdquo;
This solution allows you to lookup data from within Hiera and pass it directly
to a function where Puppet creates the individual resources as if you had typed
them into a Puppet manifest itself. The previous example can be entered into
a Hiera YAML file like so:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>sysadmins.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">users</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">gary:&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;pre&gt;&lt;code&gt;ensure</span><span class="p-Indicator">:</span> <span class="s">&#39;present&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">uid</span><span class="p-Indicator">:</span> <span class="s">&#39;5001&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">gid</span><span class="p-Indicator">:</span> <span class="s">&#39;gary&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">shell</span><span class="p-Indicator">:</span> <span class="s">&#39;zsh&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">password</span><span class="p-Indicator">:</span> <span class="s">&#39;biglongpasswordhash&#39;</span>
</span><span class='line'><span class="l-Scalar-Plain">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>And then a resource can be created inside the Puppet DSL by doing the following:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="nv">$users</span> <span class="o">=</span> <span class="nf">hiera</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">users</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span><span class='line'><span class="nf">create_resources</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">users</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Both examples are functionally identical, except the first one only uses Hiera
to get the password hash value, whereas the second one grabs both the
attributes, and their values, for a specific resource. Imagine Puppet gives you
an error with the &lsquo;gary&rsquo; user resource and you were using the latter example.
You grep your Puppet code looking for &lsquo;gary&rsquo;, but you won&rsquo;t find that user
resource in your Puppet manifest anywhere (because it&rsquo;s being created with the create_resources() function).
You will instead have to know to go into Hiera&rsquo;s data directory, then the
correct datafile, and then look for the hash of values for the &lsquo;gary&rsquo; user.</p>

<h3>Functional differences between the two approaches</h3>

<p>Functionally, you COULD do this either way. When you come up with a solution
using create_resources(), I challenge you to draw up another solution using
Puppet code in a Puppet manifest (however lengthy it may be) that queries Hiera
for ONLY the specific values necessary. Consider this example, but, instead,
you need to manage 500 users.
If you use create_resources(), you would then need to add 500 more blocks to
the &lsquo;users&rsquo; parameter in your Hiera datafiles.  That&rsquo;s a lot of YAML. And on
what level will you add these blocks? <code>prod.yaml</code>? <code>dev.yaml</code>? Are you using a
<code>common.yaml</code>? Your YAML files suddenly got huge, and the rest of your team
modifying them will not be so happy to scroll through 500 entries. Now consider
the first example using Puppet code. Your Puppet manifest suddenly grew, but it
didn&rsquo;t affect all the OTHER manifests out there: only this file. The Hiera YAML
files will still grow &ndash; but now 500 individual lines instead of 3000 lines in
the previous example. Okay, now which one is more LEGIBLE? I would argue that
the Puppet manifest is more legible, because I consider the Puppet DSL to be
very legible (again, subject to debate versus YAML). Moreover, when debugging,
you can stay inside Puppet files more often using Puppet manifests to define
your resources. Using create_resources, you need to jump into Hiera more often.
That&rsquo;s a context shift, which adds more annoyance to debugging. Also, it
creates multiple &ldquo;sources of truth.&rdquo; Suddenly you have the ability of entering
data in Hiera as well as entering it in the Puppet manifest, which may be clear
to YOU, but if you leave the company, or you get another person on your team,
they may choose to abuse the Hiera settings without knowing why.</p>

<p>Now consider an example that you might say is more tailored to create_resources().
Say you have a defined type that sets up tomcat applications. This defined type
accepts things like a path to install the application, the application&rsquo;s package
name, the version, which tomcat installation to target, and etc. Now consider
that all application servers need application1, but only a couple
of servers need application2, and a very snowflake server needs application3 (in
this case, we&rsquo;re NOT saying that all applications are on all boxes and that their
data, like the version they&rsquo;re using, is different. We&rsquo;re actually saying that
different machines require entirely different applications).</p>

<p>Using Hiera + create_resources() you could enter the resource for the
application1 at a low level, then, at a higher level, add the resource for
application2, and finally add the resource for application3 at the
node-specific level. In the end, you can do a hiera_hash() lookup to discover
and concatenate all resources from all levels of the hierarchy and pipe that to
create_resources.</p>

<p>How would you do this with Puppet code?  Well, I would create profiles for every
application, and either different roles for the different kinds of servers (i.e.
the snowflake machine gets its own role), or conditional checks inside the role
(i.e. if this node is at the London location, it gets these application profiles,
and etc&hellip;).</p>

<p>Now which is more legible? At this point, I&rsquo;d still say that separate profiles
and conditional checks in roles (or sub-roles) are more legible &ndash; including
a class is a logical thing to follow, and conditionals inside Puppet code are
easy to follow. The create_resources() solution just becomes magic. Suddenly,
applications are on the node. If you want to know where they came from, you
have to switch contexts and open Hiera data files or use the <code>hiera</code> binary
and do a debug run. If you&rsquo;re a small team that&rsquo;s been using Puppet forever,
then rock on and go for it. If you&rsquo;re just getting started, though, I&rsquo;d shy
away.</p>

<h3>Final word on create_resources?</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Some people, when confronted with a problem, think â€œI know, I&rsquo;ll use create_resources().&ldquo;
</span><span class='line'>Now they have two problems.</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The create_resources() function is often called the &ldquo;PSE Swiss Army knife&rdquo;
(or, Professional Services Engineer &ndash; the people who do what
I do and consult with our customers) because we like to break it out when we&rsquo;re
painted into a corner by customer requirements. It will work ANYWHERE, but, again,
at that cost of visibility. I am okay with someone using it so long as they
understand the cost of visibility and the potential debugging issues they&rsquo;ll hit.
I will always argue against using it, however, for those reasons. More code in
a Puppet manifest is not a bad thing&hellip;especially if it&rsquo;s reasonably legible
code that can be kept to a specific class. Consider the needs and experience
level of your team before using create_resources() &ndash; if you don&rsquo;t have a good
reason for using it, simply don&rsquo;t.</p>

<h3>create_resources()</h3>

<p><strong>PROS:</strong></p>

<ul>
<li>Dynamically iterate and create resources based on Hiera data</li>
<li>Using Hiera&rsquo;s hash merging capability, you can functionally override resource values at higher levels of the hierarchy</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Decreased visibility</li>
<li>Becomes a second &lsquo;source of truth&rsquo; to Puppet</li>
<li>Can increase confusion about WHERE to manage resources</li>
<li>When used too much, it creates a DSL to Puppet&rsquo;s DSL (DSLs all the way down)</li>
</ul>


<h3>Puppet DSL + single Hiera lookup</h3>

<p><strong>PROS:</strong></p>

<ul>
<li>More visible (sans the bit of data you&rsquo;re looking up)</li>
<li>Using wrapper classes allows for flexibility and conditional inclusion of resources/classes</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Very explicit &ndash; doesn&rsquo;t have the dynamic overriding capability like Hiera does</li>
</ul>


<h2>Using Hiera as an ENC</h2>

<p>One of the early &ldquo;NEAT!&rdquo; moments everyone has with Hiera is using it as an
External Node Classifier, or ENC. There is a function called <code>hiera_include()</code>
that allows you to include classes into the catalog as if you were to write
&ldquo;include (classname)&rdquo; in a Puppet manifest.  It works like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>london.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">classes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; profiles::london::base</span>
</span><span class='line'>  <span class="l-Scalar-Plain">&amp;ndash; profiles::london::network</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>dev.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">classes</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="nl">&amp;ndash</span><span class="l-Scalar-Plain">; profiles::tomcat::application2</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>site.pp</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='puppet'><span class='line'><span class="kd">node</span> <span class="s">default</span> <span class="p">{</span>
</span><span class='line'>  <span class="nf">hiera_include</span><span class="p">(</span><span class="err">&amp;</span><span class="ss">lsquo</span><span class="err">;</span><span class="ss">classes</span><span class="err">&amp;</span><span class="ss">rsquo</span><span class="err">;</span><span class="p">)</span>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Given the above example, the hiera_include() function will search every level
of the hierarchy looking for a parameter called &lsquo;classes&rsquo;. It returns
a concatenated list of classnames, which it then passes to Puppet&rsquo;s include()
function (in the end, Puppet will declare the profiles::london::base,
profiles::london::network, and profiles::tomcat::application2 classes). Puppet
puts the contents of these classes into the catalog, and away we go. This is
awesome because you can change the classification of a node conditionally
according to a Hiera lookup, and it&rsquo;s terrible because you can CHANGE THE
CLASSIFICATION OF A NODE CONDITIONALLY ACCORDING TO A HIERA LOOKUP!  This means
that anyone with access to the repo holding your Hiera data files can affect
changes to every node in Puppet just by modifying a magical key. It also means
that in order to see the classification for a node, you need to do a Hiera
lookup (i.e. you can&rsquo;t just open a file and see it).</p>

<p>Remember that WHOLE blog post about Roles and Profiles?  I do, because I wrote
the damn thing. <a href="http://bit.ly/puppetworkflows2">You can even go back and read it again, too, if you want to.</a>
One of the core tenets of that article was that each node get classified with a
single role. If you adhere to that (and you should; it makes for a much more
logical Puppet deployment), a node really only ever needs to be classified
ONCE. You don&rsquo;t NEED this conditional classification behavior. It&rsquo;s one of those
&ldquo;It seemed like a good idea at the time&rdquo; moments that I assure you will pass.</p>

<p>Now, you CAN use Roles with hiera_include() &ndash; simply create a Facter fact that
returns the node&rsquo;s role, add a level to the Hiera hierarchy for this role fact,
and in the role&rsquo;s YAML file in Hiera, simply do:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>appserver.yaml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">classes</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">role::application_server</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Then you can use the same hiera_include() call in the default node definition
in <code>site.pp</code>. The ONLY time I recommend this is if you don&rsquo;t already have some
other classification method. The downside of this method is that if your role
fact CHANGES, for some reason or another, classification immediately changes.
Facts are NOT secure &ndash; they can be overridden really easily. I don&rsquo;t like to
leave classification to an insecure method that anyone with root access on a
machine can change. Using an ENC or <code>site.pp</code> for classification means that the
node ABSOLUTELY CANNOT override its classification. It&rsquo;s the difference between
being authoritative and simply &lsquo;suggesting&rsquo; a classification.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Dynamic classification: no need to maintain a site.pp file or group in the Console</li>
<li>Fact-based: a node&rsquo;s classification can change immediately when its role fact does</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>Decreased visibility: need to do a Hiera lookup to determine classification</li>
<li>Insecure: since facts are insecure and can be overridden, so can classification</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puppetconf 2014 Talk - The Refactor Dance]]></title>
    <link href="http://garylarizza.com/blog/2014/10/23/puppetconf-2014-talk/"/>
    <updated>2014-10-23T08:15:42-05:00</updated>
    <id>http://garylarizza.com/blog/2014/10/23/puppetconf-2014-talk</id>
    <content type="html"><![CDATA[<p>This year at Puppetconf 2014, I presented a 1.5 hour talk entitled &ldquo;The Refactor
Dance&rdquo; that comprised nearly EVERYTHING that I&rsquo;ve written about in my Puppet
Workflows series (from writing better component modules, to Roles/Profiles,
to Workflow, and lots of stories in-between) as well as a couple of bad words,
a pair of leather pants (trousers), and an Uber story that beats your Uber
story. It&rsquo;s long, informative, and you get to watch the sweat stains under my
arms grow in an attractive grey Puppet Labs shirt.  What&rsquo;s not to love?</p>

<p><a href="https://puppetlabs.com/presentations/workshop-doing-refactor-dance-making-your-puppet-modules-more-modular-gary-larizza">To watch the video, click here to check it out!</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Dependencies and Order]]></title>
    <link href="http://garylarizza.com/blog/2014/10/19/on-dependencies-and-order/"/>
    <updated>2014-10-19T08:09:53-05:00</updated>
    <id>http://garylarizza.com/blog/2014/10/19/on-dependencies-and-order</id>
    <content type="html"><![CDATA[<p>This blog post was born out of a number of conversations that I&rsquo;ve had about
Puppet, its dependency model, and why &lsquo;ordering&rsquo; is not necessarily the way to
think about dependencies when writing Puppet manifests. Like most everything on
this site, I&rsquo;m getting it down in a file so I don&rsquo;t have to repeat this all over
again the next time someone asks. Instead, I can point them to this page (and,
when they don&rsquo;t actually <strong>READ</strong> this page, I can end up explaining everything
I&rsquo;ve written here anyways&hellip;).</p>

<p>Before we go any further, let me define a couple of terms:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dependencies     &ndash; In a nutshell, what happens when you use the metaparameters of&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               'before', 'require', 'subscribe' or 'notify' on resources in a
</span><span class='line'>               Puppet manifest: it's a chain of resources that are to be
</span><span class='line'>               evaluted in a specific order every time Puppet runs. Any failure
</span><span class='line'>               of a resource in this chain stops Puppet from evaluating the
</span><span class='line'>               remaining resources in the chain.
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>evaluate         &ndash; When Puppet determines the &lsquo;is&rsquo; value (or current state) of a&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               resource (i.e. for package resources, "is the package installed?")
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>remediate        &ndash; When Puppet determines that the &lsquo;is&rsquo; value (or current state of&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               the resource) is different from the 'should' value (or the value
</span><span class='line'>               entered into the Puppet manifest...the way the resource SHOULD
</span><span class='line'>               end up looking on the system) and Puppet needs to make a change.
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>declarative(ish) &ndash; When I use the word &lsquo;declarative(ish)&rsquo;, I mean that the order&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>               by which Puppet evaluates resources that do not contain dependencies
</span><span class='line'>               does not have a set procedure/order. The way Puppet EVALUATES
</span><span class='line'>               resources does not have a set procedure/order, but the order
</span><span class='line'>               that Puppet reads/parses manifest files IS from top-to-bottom
</span><span class='line'>               (which is why variables in Puppet manifests need to be declared
</span><span class='line'>               before they can be used).
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Why Puppet doesn&rsquo;t care about execution order (until it does)</h2>

<p>The biggest shock to the system when getting started with a declarative (ish)
configuration management tool like Puppet is understanding that Puppet describes
the end-state of the machine, and NOT the order that it&rsquo;s (Puppet) going to
take you to that state. To Puppet, the order that it chooses to affect change
in any resource (be it a file to be corrected, a package to be installed, or
any other resource type) is entirely arbitrary because resources that have no
relationship to another resource shouldn&rsquo;t CARE about the order in which they&rsquo;re
evaluated and remediated.</p>

<p>For example, imagine Puppet is going to create both <code>/etc/sudoers</code> and update
the system&rsquo;s authorized keys file to enter all the sysadmins' SSH keys. Which
one should it do first? In an imperative system like shell scripts or
a runbook-style system, you are forced to choose an order. So I ask again,
which one goes first? If you try to update the <code>sudoers</code> file in your script
first, and there&rsquo;s a problem with that update, then the script fails and the
SSH keys aren&rsquo;t installed. If you switch the order and there&rsquo;s a problem with
the SSH keys, then you can&rsquo;t <code>sudo</code> up because the <code>sudoers</code> file hasn&rsquo;t been
touched.</p>

<p>Because of this, Puppet has always taken the stance that if there are failures,
we want to get as much of the system into a working state as possible (i.e. any
resources that don&rsquo;t depend upon the failing resource are going to still be
evaluated, or &lsquo;inspected&rsquo;, and remediated, or &lsquo;changed if need be&rsquo;). There are
definitely philosophical differences here: the argument can be made that if there&rsquo;s
a failure somewhere, the system is bad and you should cast it off until you&rsquo;ve
fixed whatever the problem is (or the part of the code causing the problem). In
virtualized or &lsquo;cloud&rsquo; environments where everything is automated, this is just
fine, but in environments without complete and full automation, sometimes you
have to fix and deal with what you have. Puppet &ldquo;believes in your system&rdquo;, which
is borderline marketing-doubletalk for &ldquo;alert you of errors and give you time
to fix the damn thing and do another Puppet run without having to spin up a whole
new system.&rdquo;</p>

<p>Once you know WHY Puppet takes the stance it does, you realize that Puppet does
not give two shits about the order of resources without dependencies. If you
write perfect Puppet code, you&rsquo;re fine. But the majority of the
known-good-world does not do that. In fact, most of us write shit code. Which
was the problem&hellip;</p>

<h2>The history of Puppet&rsquo;s ordering choices</h2>

<h3>&lsquo;Random&rsquo; random order</h3>

<p>In the early days, the only resources that were guaranteed to have a consistent
order were those resources with dependencies (i.e. as I stated above, resources
that used the &lsquo;before&rsquo;, &lsquo;require&rsquo;, &lsquo;subscribe&rsquo;, or &lsquo;notify&rsquo; metaparameters to
establish an evaluation order). Every other resource was evaluted at random
every time that Puppet ran&hellip;which meant that you could run Puppet ten times
and, theoretically, resources without dependencies could be evaluated in
a different order between every Puppet run (we call this non-deterministic
ordering). This made things REALLY hard to debug.  Take the case where you had
a catalog of thousands of resources but you forgot a SINGLE dependency between
a couple of file resources. If you roll that change out to 1000 nodes, you
might have 10 or less of them fail (because Puppet chose an evaluation order
that ordered these two resources incorrectly). Imagine trying to figure out
what happened and replicate the problem. You could waste lots of time just
trying to REPLICATE the issue, even if it was a small fix like this.</p>

<p><strong>PROS</strong>:</p>

<ul>
<li>IS there a pro here?</li>
</ul>


<p><strong>CONS</strong>:</p>

<ul>
<li>Ordering could change between runs, and thus it was very hard to debug missing dependencies</li>
</ul>


<p>Philosophically, we were correct: resources that are to be evaluated in a certain
order require dependencies. Practically, we were creating more work for ourselves.</p>

<p>Incidentally, I&rsquo;d heard that Adam Jacob, who created Chef, had cited this reason
as one of the main motivators for creating Chef. I&rsquo;d heard that as a Puppet
consultant, he would run into these buried dependency errors and want to flip
tables. Even if it&rsquo;s not a true STORY, it was absolutely true for tables where
I used to work&hellip;</p>

<h3>Title-hash, &lsquo;Predictable&rsquo; random order</h3>

<p>Cut to Puppet version 2.7 where we introduced deterministic ordering with
&lsquo;title-hash&rsquo; ordering. In a nutshell, resources that didn&rsquo;t have dependencies
would still be executed in a random order, but the order Puppet chose could be
replicated (it created a SHA1 hash based on the titles of the resources without
dependencies, and ordered the hashes alphabetically). This meant that if you
tested out a catalog on a node, and then ran that same catalog on 1000 other
nodes, Puppet would choose the same order for all 1000 of the nodes. This
gave you the ability to actually TEST whether your changes would successfully
run in production. If you omitted a dependency, but Puppet managed to pick the
correct evaluation order, you STILL had a missing dependency, but you didn&rsquo;t
care about it because the code worked. The next change you made to the catalog
(by adding or removing resources), the order might change, but you would
discover and fix the dependency at that time.</p>

<p><strong>PROS</strong>:</p>

<ul>
<li>&lsquo;Predictable&rsquo; and repeatable order made testing possible</li>
</ul>


<p><strong>CONS</strong>:</p>

<ul>
<li>Easy to miss dependency omissions if Puppet chose the right order (but do you really care?)</li>
</ul>


<h3>Manifest ordering, the &lsquo;bath salts&rsquo; of ordering</h3>

<p>Title-hash ordering seemed like the best of both worlds &ndash; being opinionated about
resource dependencies but also giving sysadmins a reliable, and repeatable, way
to test evaluation order before it&rsquo;s pushed out to production.</p>

<p>Buuuuuuuuuut, y'all JUST weren&rsquo;t happy enough, were you?</p>

<p>When you move from an imperative solution like scripts to a declarative(ish)
solution like Puppet, it is absolutely a new way to think about modeling your
system. Frequently we heard that people were having issues with Puppet because
the order that resources shows up in a Puppet master WASN&rsquo;T the order that Puppet
would evaluate the resources. I just dropped a LOT of words explaining why this
isn&rsquo;t the case, but who really has the time to read up on all of this? People
were dismissing Puppet too quickly because their expectations of how the tool
worked didn&rsquo;t align with reality. The assumption, then, was to align these
expectations in the hopes that people wouldn&rsquo;t dismiss Puppet so quickly.</p>

<p><a href="http://puppetlabs.com/blog/introducing-manifest-ordered-resources">Eric Sorenson wrote a blog post on our thesis and experimentation</a>
around manifest ordering that is worth a read (and, incidentally, is shorter
than this damn post), but the short version is that we tested this theory out
and determined that Manifest Ordering would help new users to Puppet. Because
of this work, we created a feature called &lsquo;Manifest Ordering&rsquo; that stated that
resources that DID NOT HAVE DEPENDENCIES would be evaluated by Puppet in the
order that they showed up in the Puppet manifest (when read top to bottom). If
a resource truly does not have any dependencies, then you honestly should not
care one bit what order it&rsquo;s evaluated (because it doesn&rsquo;t matter).  Manifest
Ordering made ordering of resources without dependencies VERY predictable.</p>

<p>But&hellip;.</p>

<p>This doesn&rsquo;t mean I think it&rsquo;s the best thing in the world. In fact, I&rsquo;m really
wary of how I feel people will come to use Manifest Ordering. There&rsquo;s a reason
I called it the &ldquo;bath salts of ordering&rdquo; &ndash; because a little bit of it, when
used correctly, can be a lovely thing, but too much of it, used in unintended
circumstances, leads to hypothermia, paranoia, and the desire to gnaw someone
else&rsquo;s face off. We were/are giving you a way to bypass our dependency model by
using the mental-model you had with scripts, but ALSO telling you NOT to rely
on that mental-model (and instead set dependencies explicitly using metaparameters).</p>

<p>Seriously, what could go wrong?</p>

<p>Manifest Ordering is not a substitution for setting dependencies &ndash; that IS NOT
what it was created for. <strong>Puppet Labs still maintains that you should use
dependencies to order resources and NOT simply rely on Manifest Ordering as
a form of setting dependencies!</strong> Again, the problem is that you need to KNOW
this&hellip;and if Manifest Ordering allows you to keep the same imperative
&ldquo;mindset&rdquo; inside a declarative(ish) language, then eventually you&rsquo;re going to
experience pain (if not today, but possibly later when you actually try to
refactor code, or share code, or use this code on a system that ISN&rsquo;T using
Manifest Ordering). A declarative(ish) language like Puppet requires seeing
your systems according to the way their end-state will look and worrying about
WHAT the system will look like, and not necessarily HOW it will get there. Any
shortcut to understanding this process means you&rsquo;re going to miss key bits of
what makes Puppet a good tool for modeling this state.</p>

<p><strong>PROS:</strong></p>

<ul>
<li>Evaluation order of resources without dependencies is absolutely predictable</li>
</ul>


<p><strong>CONS:</strong></p>

<ul>
<li>If used as a substitution for setting dependencies, then refactoring code (moving around the order in which resources show up in a manifest) means changing the evaluation order</li>
</ul>


<h2>What should I actually take from this?</h2>

<p>Okay, here&rsquo;s a list of things you SHOULD be doing if you don&rsquo;t want to create
a problem for future-you or future-organization:</p>

<ul>
<li>Use dependency metaparameters like &lsquo;before&rsquo;, &lsquo;require&rsquo;, &lsquo;notify&rsquo;, and &lsquo;subscribe&rsquo; if resources in a catalog NEED to be evaluated in a particular order</li>
<li>Do not use Manifest Ordering as a substitute for explicitly setting dependencies (disable it if this is too tempting)</li>
<li>Use Roles and Profiles for a logical module layout (see: <a href="http://bit.ly/puppetworkflows2">http://bit.ly/puppetworkflows2</a> for information on Roles and Profiles)</li>
<li>Order individual components inside the Profile</li>
<li>Order Profiles (if necessary) inside the Role</li>
</ul>


<p>And, seriously, trust us with the explicit dependencies. It seems like a giant
pain in the ass initially, but you&rsquo;re ultimately documenting your infrastructure,
and a dependency (or, saying &lsquo;this thing MUST come before that thing&rsquo;) is a pretty
important decision. There&rsquo;s a REASON behind it &ndash; treat it with some more weight
other than having one line come before another line, ya know? The extra time
right now is absolutely going to buy you the time you spend at home with your
kids (and by &lsquo;kids&rsquo;, I mean &lsquo;XBox&rsquo;).</p>

<p>And don&rsquo;t use bath salts, folks.</p>
]]></content>
  </entry>
  
</feed>
