<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: luggage | Shit Gary Says]]></title>
  <link href="http://garylarizza.com/blog/categories/luggage/atom.xml" rel="self"/>
  <link href="http://garylarizza.com/"/>
  <updated>2013-01-21T09:26:35-08:00</updated>
  <id>http://garylarizza.com/</id>
  <author>
    <name><![CDATA[Gary larizza]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Git for Mac Sysadmins]]></title>
    <link href="http://garylarizza.com/blog/2012/01/24/using-git-for-mac-sysadmins/"/>
    <updated>2012-01-24T15:25:00-08:00</updated>
    <id>http://garylarizza.com/blog/2012/01/24/using-git-for-mac-sysadmins</id>
    <content type="html"><![CDATA[<p>As a former Mac Sysadmin, I frequently felt like I had one toe in the world in which Linux Sysadmins frequently found themselves, but was surrounded by a culture of GUI-Clickery that either feared, scorned, or flat-out avoided tools that were command-line based (or, as many will point out, used the GUI (Graphic User Interface) tools because 'they worked' and that was all they needed).  This sucked because Linux Sysadmins have some tools that, as a current colleague would say, 'are kind-of awesome.'</p>

<p>One of those tools is Git, which is a Distributed Version Control System (or, DVCS).  Git, in a TOTAL nutshell, is a tool that allows you to create multiple 'what-if scenarios' with very little cost and the ability to save yourself from...well, yourself.</p>

<h2>Yes - You're Going to Use the Command Line</h2>

<p>Like I mentioned before, the GUI is ingrained in the culture of the Mac.  It wasn't until OS X that Mac Sysadmins finally had a proper command-line (which I will refer to as the CLI, which is short for Command Line Interface.  If you're not familiar with that terminology, I'm speaking about the interface you get when you run /Applications/Utilities/Terminal.app), so we're a bit 'new' to the whole idea.  I can help you if you fear or avoid the CLI; there's always room for learning and I'll try to hold your hand as much as possible.  For those that downright refuse to use the CLI...well, I'm sorry?</p>

<h2>What IS Git?</h2>

<p>Git is relatively new in the DVCS world (being initially released in 2005).  Developers have been using DVCS for MANY years with tools like CVS, Subversion, Git, Mercurial, and others.  For a team of developers who ALL need to make contributions to a SINGLE project or code base, it's vital that they have a way to modify a file without breaking something that someone else is doing.  That's what DVCS tools do - allow you to take something as large as a code base like OS X 10.7 (or something as small as a directory with a couple of files) and make changes without affecting everyone else who's working on the SAME code base (or files in the directory).</p>

<p>So why am I choosing to talk about Git instead of, say, Subversion?  That's easy: lightweight branching and merging.  Git allows you to easily create a 'topic branch' (or, using the metaphor above, a 'what-if scenario'), make changes, and see if your changes are favorable or if they downright stink. If your changes are desirable, you can then 'merge' your topic branch back in with your master branch (or, the original state the files were in when you created the topic branch in the first place).  If the changes don't work well, you can just delete the topic branch and 'no-harm, no-foul'; your original files remain unchanged and in the pristine condition that they existed when you first created the topic branch.  True, Subversion could do the same thing, but Git allows MANY people to do the same thing and then EASILY merge in EVERYONE'S changes without having to fight Subversion (just trust me on this if you've never used Subversion).</p>

<p>And why am I choosing to talk about Git instead of Mercurial?  Easy - Git is what I learned :)  As I understand it Mercurial functions similarly, and I truly don't have the experience with Mercurial to tell you the differences.  I'm talking about Git because Git is what I use and Git is what my company uses.</p>

<h2>So what does this have to do with me as a Mac Sysadmin?</h2>

<p>Good question.  Mac Sysadmins are more frequently finding themselves having to use the CLI to tune their clients and servers.  Also, many Mac Sysadmins are finding that certain CLI tools are working better for their teams (in terms of simplicity, responsibility, and visibility).  As they dip their toes into this CLI world, they're finding that they want the same features they had in the GUI: the ability to do a 'save-as', to create 'versions', and to have the ability to have a rollback function similar to Time Machine.  Git gives you this through the CLI (or, yes, even through the GUI as I will mention later in the article).</p>

<p>If you're ready to take that step then follow me&hellip;</p>

<h2>A note on Git and Github</h2>

<p>You might have heard of <a href="http://www.github.com">Github</a>.  Github is a free (they have a free tier and plenty of subscription tiers of service) service that allows you to 'push' your git repositories up to them for storage in 'the cloud'.  Github is basically centralized-storage for your git repositories and is NOT NECESSARY for you to use git as a tool.  In reality, you CAN use Github or setup something like Gitolite on a local server in your environment to get most of the benefits of Github without having to push your repositories to Github's servers.</p>

<p>The bottom line: Github and git (the tool) are two different things.  Github didn't create git, and git doesn't need Github to work properly.  Keep that in mind as you read through.</p>

<h2>Installing Git</h2>

<p>Git can be installed in a variety of ways.  First and foremost, you can download the latest package from <a href="http://code.google.com/p/git-osx-installer/">Git's Googlecode Page</a>.  You can also choose to install git through Macports or Homebrew as long as you have them installed (both of which require the Developer Tools...but so does The Luggage, the tool we'll be using later).  Simply download the package from <a href="http://code.google.com/p/git-osx-installer/">Git's Googlecode Page</a>, install it, and you should be good to go!</p>

<p>If you're using Macports, make sure the Developer Tools are installed, Macports is installed, and then do the following from the command line (<strong>PLEASE NOTE: The dollar sign is a prompt - you SHOULDN'T type it.  Lines BEGINNING with a dollar sign, or a prompt, should be typed by you.  Lines that DON'T begin with a prompt represent the output you receive from typing the command.  If you don't see a line that DOESN'T begin with a prompt, then I'm not listing the output.  Got it?  Good!</strong>):</p>

<p>```</p>

<pre><code>$ sudo port install git-core
</code></pre>

<p>```</p>

<p>If you're using Homebrew, make sure the Developer Tools are installed, Homebrew is installed, and then do the following:</p>

<p>```</p>

<pre><code>$ sudo brew install git
</code></pre>

<p>```</p>

<p>To check to see where and what version of git is installed, execute the following commands :</p>

<p>```</p>

<pre><code>$ which git
$ git --version
</code></pre>

<p>```</p>

<p>You should receive the path to where git is installed after you run the first command, and you should receive the version of git that's currently installed on your system.  Any version of Git greater-than or equal to 1.7 is probably ideal, though most of the commands we'll be using will probably work just fine with previous versions.</p>

<h2>Your first Git repo</h2>

<p>I find it's easier to understand Git if I describe an actual scenario instead of talking in terms of 'git can do...'.  I'm going to talk about using git with <a href="http://github.com/unixorn/luggage">The Luggage</a>.  <a href="http://glarizza.posterous.com/an-intro-to-using-the-luggage-for-packaging">I've written about The Luggage in several articles on this site</a>, so feel free to familiarize yourself with it if you haven't used the tool before.  As a quick review, The Luggage is a tool that lets you create plain text Makefiles that can be used to build packages to install files, deploy scripts, and basically distribute 'things' to the users in your organization.  Auditing HOW a package is made can be incredibly difficult for a team of sysadmins, but The Luggage helps you with this by using plain text Makefiles.  Git will give you the ability to track WHO made changes, WHEN they were made, and ROLLBACK the changes if you notice something undesirable happening.  Git and The Luggage are a perfect combo if you're a sysadmin.</p>

<p>Incidentally, The Luggage exists as a Github repository, so we have to CLONE it (or download it) from Github first before we can start playing with it.  I recommend creating a directory in your home directory (/Users/-username-) and cloning your repositories there - that way you retain ownership of the files and can work on them at will.  I put all my git repositories in ~/src, but if you're using something like Mobile Home Directories or even Network Home Directories, then you'll want to make sure that you're not syncing these directories back to some central location and burning up your quota in some fashion.  Let's create our repositories directory and clone The Luggage source code with these steps:</p>

<p>```</p>

<pre><code>$ mkdir -p ~/src
$ cd ~/src
$ git clone git://github.com/unixorn/luggage.git
</code></pre>

<p>```</p>

<p>Doing this will create the ~/src directory where we're putting all our repositories and download The Luggage source code to ~/src/luggage.  As you might be able to infer, git clone will clone an existing git repository from its location on another server (we call that the remote location, or just remote for short) down to a local directory.  This is usually how many sysadmins first encounter git - by needing to download something from Github or a remote server.  Let's look and see what git knows about this repo by doing the following:</p>

<p>```</p>

<pre><code>$ git remote -v
origin  git://github.com/unixorn/luggage.git (fetch)
origin  git://github.com/unixorn/luggage.git (push)
</code></pre>

<p>```</p>

<p>This command will list all the remote repositories that we're tracking.  By default, you will get a remote by the name of 'origin' that lists the location where you originally cloned the repository (in our case, this is Github).</p>

<p>Why is it listed twice?  Well, with git, you can pull down, or fetch, changes from a remote repository as well as push up changes from your LOCAL repository to the remote repository.  Frequently these paths will be the same, but in our case these links are to the READ-ONLY version of this repository, so trying to push changes will always fail because we don't have access.  We'll talk later about how you can push up changes, but for now let's create our OWN repository instead of working with someone ELSE'S.</p>

<h2>Creating your OWN git repo</h2>

<p>The Luggage has a directory called Examples, but it's absent of any actual examples.  We want to create our own directory where we can store our Luggage Examples.  For the purposes of this demo, I'm going to create a directory called luggage_examples that will contain our...well... Luggage examples:</p>

<p>```</p>

<pre><code>$ cd ~/src
$ mkdir luggage_examples
</code></pre>

<p>```</p>

<p>Now that we have a directory, we need to make sure that git is tracking our changes so that we can create those 'what if' scenarios and save our work.</p>

<p>```</p>

<pre><code>$ cd ~/src/luggage_examples
$ git init
Initialized empty Git repository in /Users/gary/src/luggage_examples/.git/
</code></pre>

<p>```</p>

<p>Git created a new empty repository at ~/src/luggage_examples and created a .git directory inside luggage_examples.  This .git directory is where git stores all its dynamic data that's pertinent to your repository, so MAKE SURE not to delete it or modify any files in there (without knowing what you're doing).</p>

<p>That's it!  We've created a repository!  Now let's actually see how git works locally on your machine.</p>

<h2>Working with Files</h2>

<p>As I mentioned before, you don't NEED Github to use git.  Git functions as a mechanism to 'version' your files so you can rollback to a previous version or create our 'what-if' scenarios and then accept (merge) or deny (destroy) them depending on our needs.  You can easily create a git repository on your local computer ONLY, but of course you lose the ability to restore your work if your hard drive malfunctions.  This is what Github gives us, and we'll look at that functionality later.</p>

<p>The example I'm going to use is based on the previous blog post I wrote on <a href="http://glarizza.posterous.com/using-googles-crankd-application-tracking-cod">Using the Google Mac Sysops Crankd Code</a>  Let's create a directory for this example and create a starter Makefile:</p>

<p>```</p>

<pre><code>$ mkdir -p ~/src/luggage_examples/crankd_google
$ cd ~/src/luggage_examples/crankd_google
$ vim Makefile
</code></pre>

<p>```</p>

<p>I use vi or vim to edit files from the Terminal.  Feel free to use any text editor you like (nano, emacs, Textmate, TextWrangler, etc...), but CREATE a file called 'Makefile' (note the capital M) and put it in ~/src/luggage_examples/crankd_google.  Here's what I'll put into this file:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Crankd Luggage Example  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='make'><span class='line'><span class="err">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;pre&gt;&lt;code&gt;# Title</span><span class="o">:</span>       <span class="m">Crankd-Google Example</span>
</span><span class='line'><span class="c"># Author:      Gary Larizza</span>
</span><span class='line'><span class="c"># Description: Something so Marnin doesn&#39;t kill me w/ postinstalls :)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">include /Users/gary/src/luggage/luggage.make</span>
</span><span class='line'>
</span><span class='line'><span class="nv">TITLE</span><span class="o">=</span>Crankd-Google
</span><span class='line'><span class="nv">REVERSE_DOMAIN</span><span class="o">=</span>com.googlecode
</span><span class='line'><span class="nv">PAYLOAD</span><span class="o">=</span>pack-crankd
</span><span class='line'><span class="err">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Great, so we have our skeleton of a file!  The file is saved in our folder, but we haven't actually told git to track the file (and so git is AWARE that the file EXISTS, but it isn't tracking its changes...yet).  This is a good time to explain the three states in which files can exist in a git repository.</p>

<h2>The Three Stages of Files: Working Tree, Index, and Repository</h2>

<p>Git has three 'locations' by which a file can exist (even though it technically exists, in our case, in ~/src/luggage_examples/crankd_google).  These three locations are called the working tree, the index, and the repository</p>

<h2>The Working Tree</h2>

<p>When you put a file in a directory that's being managed by git, but you haven't told git to track the files changes, then this file is said to be in the working tree.  Our file we just created, Makefile, exists in the working tree currently.  Git knows that the file EXISTS, but it hasn't saved the file's 'state' so we can rollback the file if need be.</p>

<h2>The Index</h2>

<p>The index is also known as the cache or the staging area, and it's a place to put files before you're ready to make a 'commit' (which is something of a 'milestone' or a version).  A commit is a representation of a point in time in the history of your git repository.  Think of it as a snapshot of your repository - 'this is how our files looked at this specific time'.  With commits, you can always rollback to a specific 'commit' (or even advance to a future commit if you had rolled-back to an earlier commit).  In order to rollback to a specific version of a file, though, you need to make a commit, and in order to make a commit you need to tell git what FILES will comprise our commit.  As I mentioned, a commit is just a point in time...but it doesn't HAVE to be a point in time for a SINGLE file.  A commit can represent a specific point in time for a NUMBER of files all at once.  To make life easier for everyone, though, if you make a commit comprised of multiple files, then you want to make sure that the changes to the multiple files all represent a single functional change (for example, say we wanted to change a file that existed in our crankd_google folder that was being copied into a package, but we ALSO had to change the Makefile to change WHERE this file was to be put in the final package.  These two changes are related and comprise a single functional change, so you would want to make a commit with the changes to both files at once.).</p>

<p>Our Makefile exists in the working tree currently, but we want to put it in the index because we're ready to make a commit (no, our Makefile functionally doesn't DO anything yet, but we want to make a commit so we can rollback to this point in time should we mess up anything).  Understand that the locations of the 'working tree' and 'index' are relative to git ONLY.  Yes, this file lives in ~/src/luggage_examples, and it will CONTINUE to exist in that directory (as far as the OS X filesystem is concerned), but to git it currently exists in the working tree.  How do we know that the file is in the working tree and NOT in the index?  Use the git status command to show you that info:</p>

<p>```</p>

<pre><code>$ git status

# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add ..." to include in what will be committed)
#
# Makefile
nothing added to commit but untracked files present (use "git add" to track)
</code></pre>

<p>```</p>

<p>Anything listed under 'Untracked files:' is in the working tree.  You can add a file to the index by doing the following:</p>

<p>```</p>

<pre><code>$ git add Makefile
$ git status

# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached ..." to unstage)
#
# new file:   Makefile
#
</code></pre>

<p>```</p>

<p>Great, the file is in the index!  Notice that the file is listed under 'Changes to be committed:' meaning that it's in the index but NOT YET committed (or, 'in the repository').</p>

<h2>The Repository</h2>

<p>The Repository is where your files exist once they've been made part of a commit.  As I mentioned before, files must be committed before we can roll back their states (and their states can only be rolled back to individual commits).  You can never rollback a file's state UNLESS it's tied to a commit.  If you made a commit to a file last week and haven't made another since, but wanted to revert a file to how it existed three days ago, you would be out of luck.  Git ONLY rolls back to specific commits (this is why it's important to make frequent commits).  Before we make a commit, however, we need to make sure to identify ourself to git (if you haven't previously set this up).  The user.email and user.name settings are the most important settings as they will be used to trace back what code you committed.  If you're not sure of how git is setup, use the following command to list the git config settings:</p>

<p>```</p>

<pre><code>$ git config -l
user.name=Gary Larizza
user.email=gary@puppetlabs.com
</code></pre>

<p>```</p>

<p>Should the user.name and user.email settings NOT be configured, you can configure them with the following commands:</p>

<p>```</p>

<pre><code>$ git config user.name 'Your name'
$ git config user.email your@email.com
</code></pre>

<p>```</p>

<p>Now that you've been identified (so we can lay the blame on you in the future), let's actually commit some code.  The <strong>git commit</strong> command allows git to commit all staged files to the repository in one fell swoop.</p>

<p>Every commit has three things: the list of files and CONTENT of the files that should be committed, a SHA1 hash value representing the commit itself (essentially, a unique identifier for the commit so it can be tracked), and the commit message describing the what and why of the commit.</p>

<p><strong>Creating a commit message seems insignificant but should NOT be taken lightly.</strong>  Great commit messages usually consist of a title line containing no more than 60 characters followed by a paragraph describing the changes.  Because many people may potentially need to trace your code and commits, it's important to list how your code functioned previously, the reasoning behind the change, and what specifically was changed.  Don't skimp with your commit messages!  Always assume that the next person to maintain your code owns many dangerous weapons and knows where you sleep, so do that person a favor and be as kind to them (in the form of great commit messages) as possible!</p>

<p>Let's begin the process of making a commit by issuing the following command:</p>

<p>```</p>

<pre><code>git commit
</code></pre>

<p>```</p>

<p>Executing <strong>git commit</strong> will drop you into the default text editor (which is vim by default - you can change this by running <strong>git config core.editor /path/to/your/editor</strong> before doing git commit) and show the following:</p>

<p>```</p>

<pre><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached ..." to unstage)
#
# new file:   Makefile
#
</code></pre>

<p>```</p>

<p>Note that everything that begins with a hash ( # ) is solely for YOUR benefit and will be stripped out of the commit message, so don't worry about it being included.  Here's an example of a commit message I would use in this instance:</p>

<p>```</p>

<pre><code>Initial commit for crankd_google code

Previously we didn't have an example for creating a package of the 
Google Mac Sysops code.  This commit adds the shell for the Makefile and
includes the luggage.make file in ~/src/luggage.
</code></pre>

<p>```</p>

<p>Great!  When you save and close your editor, you should see something that looks like this:</p>

<p>```</p>

<pre><code>[master (root-commit) f423ac6] Initial commit for crankd_google code
 1 files changed, 9 insertions(+), 0 deletions(-)
 create mode 100644 Makefile
</code></pre>

<p>```</p>

<p>This tells us that we made a commit on the master branch with a SHA1 hash ID beginning in f423ac6 being attributed to this commit.  In most cases, the first 7 digits of the hash are all you need for uniqueness when you refer to this commit, and that's usually all that git will provide you in THIS instance.  YOUR SHA1 hash won't match the hash provided above (hence a unique ID), so don't panic if it doesn't match up for you.  And that's it!  We've done it!  Now what?</p>

<h2>Examining your Work</h2>

<p>Git tracks the ENTIRE history of a repository, and thus will track any and every commit made.  To display this history, run the following command:</p>

<p>```
$ git log
commit f423ac6e9548d93f53b15d1154723c5abcd69738
Author: Gary Larizza
Date:   Sun Jan 22 23:27:31 2012 -0500</p>

<pre><code>Initial commit for crankd_google code

Previously we didn't have an example for creating a package of the
Google Mac Sysops code.  This commit adds the shell for the Makefile and
includes the luggage.make file in ~/src/luggage.
</code></pre>

<p>```</p>

<p>By default, git log will show ALL information about ALL of your commits (including the full commit message).  There's a LARGE number of arguments that git log will accept that allows you to format the output for ANY purpose.  One of the common lists of arguments that I like to employ is the following (long) command:</p>

<p>```</p>

<pre><code>$ git log --pretty=format:'%C(yellow)%h%C(reset) %s %C(cyan)%cr%C(reset) %C(blue)%an%C(reset) %C(green)%d%C(reset)' --graph --date-order
* f423ac6 Initial commit for crankd_google code 10 minutes ago Gary Larizza  (HEAD, master)
</code></pre>

<p>```</p>

<p>This format both colorizes the output for readability and also shows a nice graph of commits as you do things like branching and merging.  Here's an example of this command (with line length chopped for brevity) being run on a repository with many commits:</p>

<p>```</p>

<pre><code>* 72a2fe0 (#5445) Create /var/lib/puppet in OS X Package 26 hours ago Gary Larizza  (HEAD, gary/bug/2.7.x/5445_crea
*   c6667c5 Merge pull request #324 from glarizza/bug/2.7.x/2273_launchd_dashw 12 days ago Daniel Pittman  (origin/
|\  
* \   bc6c642 Merge pull request #318 from glarizza/bug/2.7.x/11202_apple_rake 12 days ago Michael Stahnke 
|\ \  
| * | 6c14a28 Build a Rake task for building Apple Packages 12 days ago Gary Larizza  (gary/bug/2.7.x/11202_apple_r
* | |   5ec5657 Merge pull request #127 from adrienthebo/ticket/2.7.x/8341-prevent_duplicate_loading_of_facts 12 da
|\ \ \  
* \ \ \   450da6a Merge pull request #92 from duritong/tickets/2.7.x/1886 12 days ago Daniel Pittman 
|\ \ \ \  
| | | | * d5bef5e (#2773) Use launchctl load -w in launchd provider 12 days ago Gary Larizza  (gary/bug/2.7.x/2273_
* | | | |   1cb2b6a Merge branch 'ticket/2.7.x/11714-envpuppet' into 2.7.x 12 days ago Josh Cooper 
|\ \ \ \ \  
| |_|_|_|/  
|/| | | |   
| * | | | 5accc69 (#11714) Use **%~dp0** to resolve bat file's install directory 12 days ago Josh Cooper 
* | | | |   fe79537 Merge pull request #323 from glarizza/bug/2.7.x/fix_launchd_spec 12 days ago Jeff McCune 
|\ \ \ \ \  
| * | | | | c865a80 Clean up launchd spec tests 12 days ago Gary Larizza  (gary/bug/2.7.x/fix_launchd_spec, bug/2.7
|/ / / / /
</code></pre>

<p>```</p>

<p>As you can see, git log is powerful and handy to list out what's happened to your repository.  You'll also notice that it lists WHO made the changes, which is handy if you have MANY people contributing to the same code base.</p>

<h2>That's it for now</h2>

<p>Hey , what gives?! We haven't really DONE anything!  Git has a tremendous amount of power, and it's important to know WHAT'S happening before I can progress and show you the power of git.  This article is ALREADY quite long, so I've broken it up for 'easier' reading.  Rest assured, in parts 2 and beyond we will modify files, create topic branches, merge topic branches, use Github (for backup AND to allow others to contribute to your project), and much more.  Stay tuned for the following article(s) and as always, put any questions in the comments or email me directly!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started with The Luggage]]></title>
    <link href="http://garylarizza.com/blog/2010/12/21/getting-started-with-the-luggage/"/>
    <updated>2010-12-21T09:47:00-08:00</updated>
    <id>http://garylarizza.com/blog/2010/12/21/getting-started-with-the-luggage</id>
    <content type="html"><![CDATA[<p>With the current movement in the Mac Community toward modular imaging strategies, there's a spike in the need for properly formed package installers. Apple's package format is well documented for its benefits and flaws and there are a string of applications that will help you create your perfect package (from Apple's Packagemaker to the many third-party applications).  While all the various package creation applications will ultimately create a desirable package in the end, very few of them have the triple-threat of easy code-review, replication, and portability.  This is where The Luggage comes in.</p>

<p><a href="http://github.com/unixorn/luggage">The Luggage</a> is a packaging system based on GNU's make command that is found on most every *nix-based operating system (OS X included).  Joe Block, the author, open-sourced the project based on an internal Google tool for creating packages with Makefiles.  By using Makefiles, every member of your team can quickly glance at the file and see exactly what is being inserted into a package.  Changes can be made and committed quickly, errors can be squashed without tearing apart .pkg files, and you can reproduce packages quickly and efficiently without wading through many GUI windows.</p>

<h2>Why do I need to Package?</h2>

<p>Many vendors already ship properly formatted package installers for their software - and for that we thank them.  There are still a couple of major software vendors that choose to use unique third-party package "wrappers" to install their software.  While this is fine if you only ever need to install that software on one machine, it makes software deployment...difficult.  Because of this, systems administrators need to re-package this software into a proper package installer that will deploy and install silently.</p>

<p>If you're a fan of open-source software, you will find that many projects do not offer their software in Apple-friendly packages.  The Luggage will help you wrap their source files into a package format that can be distributed to your machines.</p>

<p>Finally, you may have a whole bevy of scripts that you use for configuration/customization of your clients.  These scripts can easily be deployed via ARD or wrapped into a payload-free package with a single postinstall script.  The Luggage will help you keep track of all your scripts and package them for distribution.</p>

<p>As I've said before, there are other third-party applications out there that will create a package to your needs.  Many will use snapshotting (or fseventsd monitoring) to create a package based on what's changed on your system.  While this is lightning fast (in most cases), you will need to redo this whole process if something needs to be changed in the resultant package.</p>

<h2>How do we use The Luggage?</h2>

<p>As we said before, The Luggage is just a giant Makefile.  Make has its own unique language, so you need to obey its syntax and formatting standards.  I've linked to the <a href="http://www.gnu.org/software/make/manual/make.html">GNU make manual here</a> so you can get a quick overview of how it works (WARNING, it's quite large), but this guide will cover all the basics you need to know to get started.</p>

<p>Note that while it is <strong>NOT NECESSARY TO COMPLETELY UNDERSTAND MAKE TO BEGIN USING THE LUGGAGE</strong>, it will help you out tremendously as you start to create complicated packages if you DO understand make's nuances. This article may be long, but that's only to make sure that the reader understands what is going on in the background.</p>

<h2>The luggage.make File</h2>

<p>The base of everything you will do with The Luggage is a file called luggage.make.  It is by no means definitive, and you're encouraged to add to it should you encounter a situation where a recipe doesn't exist for a directory into which you want to install files (Don't worry, we'll get into this later), but it does serve as the basis for all packages you're going to be creating.</p>

<p>At the top of the file are all the variable declarations.  Anything that begins with SOMETHING=somethingelse is setting a variable that we will encounter later.  Many of these variables (such as PACKAGEMAKER, WORK_D, CP, INSTALL, and so on) are paths to various commands that we will need in our rules (setting absolute paths to common commands saves typing later and helps us avoid errors with things like PATH environment variables).  Dereferencing these variables in a Makefile is done with a syntax that looks like this -> ${CP} (this outputs the value of the CP variable, which is actually <strong>/bin/cp</strong>).  Note that you DO NOT use quotes when you set a variable (i.e. if you want to set the path to CP you do it with CP=/bin/cp and NOT by doing CP="/bin/cp") - if you DO use quotes, they will be included in the value of that variable (which will cause you all kinds of problems).</p>

<p>Next, we have the target stanzas.  A target (or a rule - I will use the word rule throughout the article) is setup to look like this:</p>

<p>``` make</p>

<pre><code>        o-something: l_usr_bin
        @-echo "Commands are entered here"
        @-echo "Everything below our rule is executed"
</code></pre>

<p>```</p>

<p>In this case, the <strong>target</strong>, or <strong>rule</strong>, is called <strong>do-something</strong> and has dependencies based on ANOTHER rule that's called <strong>l_usr_bin</strong>.  Below this line is called our <strong>recipe</strong>, and right now there are two echo commands.  If the above code was in a blank text file called Makefile we could execute the two echo commands by running the following command from the command line:</p>

<p>``` bash</p>

<pre><code>    make do-something
</code></pre>

<p>```</p>

<p>This would in turn echo the two lines of text below the do-something rule (This is not totally true - since we haven't defined a rule for l_usr_bin it would probably error out, but I've kept that dependency in the above example to show you how a rule works.).  Looking specifically at luggage.make, the target stanzas define the behavior for The Luggage's various behaviors (make pkg, make dmg, make zip, and so on).  Note that since many of these rules have dependencies on OTHER rules, a simple command of <strong>make pkg</strong> will trigger.</p>

<p>Next, you will encounter the Target directory rules.  This is the part of the luggage.make file that you may need to edit.  Joe has done a great job of defining the most popular directories into which you will install files/applications/etc. but it would be impossible for him to define EVERY location that you could possibly need.  Here is the structure of creating a Directory Rule:</p>

<p>``` make</p>

<pre><code>        l_etc_puppet: l_etc
        @sudo mkdir -p ${WORK_D}/etc/puppet
        @sudo chown -R root:wheel ${WORK_D}/etc/puppet
        @sudo chmod -R 755 ${WORK_D}/etc/puppet
</code></pre>

<p>```</p>

<p>This rule will create an /etc/puppet directory in Luggage's working directory (The variable WORK_D will be used frequently - it's the temporary directory that The Luggage creates to simulate the target volume onto which it's installing files.  Everything following ${WORK_D} will be the <strong>EXACT PATH</strong> into which files will be installed on the machine that runs your package.)  These Directory Rules become very important when we create custom Makefiles because they serve as dependencies which create the directories in The Luggage's Working Directory. In a nutshell, if you're installing files into a directory with The Luggage, you need to have a Directory Rule that creates this directory first.  Bottom Line: if you don't FIND a Directory Rule for a directory where you will be installing files, then you'll need to create one.</p>

<p>Finally are the File Packaging Rules.  These are handy shortcut rules that will keep your makefiles very short and readable.  In a nutshell, Joe has defined some of the most common directories to which files are installed and created one-line commands that will install specific files into those directories.  For example, say you were creating a custom Makefile in a directory that also had a launchd plist called <strong>com.foo.bar.plist</strong> in it.  If ALL you needed to do was create a package that installed that launchd plist into the /Library/LaunchDaemons directory you could setup your Makefile like this:</p>

<p>``` make</p>

<pre><code>include /usr/local/share/luggage/luggage.make

TITLE=install_foo_launchd_plist
REVERSE_DOMAIN=com.foo
PAYLOAD=pack-Library-LaunchDaemons-com.foo.bar.plist
</code></pre>

<p>```</p>

<p>The PAYLOAD variable tells The Luggage which rules to execute.  In this case, it's executing the File Packaging Rule for launchd plists (pack-Library-LaunchDaemons-%) that creates the ${WORK_D}/Library/LaunchDaemons directory, installs the com.foo.bar.plist file into it, sets the correct permissions, and then executes the Packagemaker command line tool to create your package installer. Congratulations, you created a package in 5 lines of code!</p>

<h2>Preparing for using The Luggage</h2>

<p>The Luggage is fairly self contained, but it DOES use Apple's Packagemaker command line tool - and the way to install THAT is to download and install the Developer Tools for your computer's OS version (There are different Developer Tools packages for 10.6, 10.5, and so on).  The Developer Tools can be downloaded from <a href="http://developer.apple.com">Apple's Developer Site</a>, but you must create a (free) developer account first.  If you're a Mac sysadmin, you should already have all of this.</p>

<p>Once the Developer Tools have been installed you will then need to install The Luggage.  You can use The Luggage to create an installer package for The Luggage (Weird, yes) by first <a href="http://github.com/unixorn/luggage">downloading the source code from Github.</a>  Just click on the big Downloads button in the upper right corner of the screen and download a zip version of the files.  From there, double-click on the downloaded zip file to open it, open up Terminal and change to the folder that was created which contains The Luggage's source code, and execute the following command:</p>

<p>``` bash</p>

<pre><code>    sudo make pkg
</code></pre>

<p>```</p>

<p>This will create an installer package which can be run.  This package installs The Luggage into the /usr/local/share/luggage directory (Don't believe me? Check the Makefile for your self!).  You're now ready to use The Luggage!</p>

<p>Before we get into the package creation examples, we need to talk about directory structure and version control systems (svn, hg, git, etc...).  When you create new packages with The Luggage, it's necessary to create a new Makefile in a new directory.  I like to use the /usr/local/share/luggage/examples directory to create my packages.  The easiest way to begin a new package is to copy a directory that contains a working Makefile and simply tailor it to your needs.  Unless your job is SOLELY packaging (or you're a unix graybeard), you're NOT going to remember all the syntax and nuances of make.  Don't re-create the wheel - just copy and edit.</p>

<p>Next, you're going to want to backup your files and/or have a versioning system.  Version control systems (like Subversion, Mercurial, Git, and the like) are becoming increasingly popular <a href="http://www.agileweboperations.com/the-state-of-devops">with the current DevOps movement</a>, so it might be a good idea to start playing with one NOW while you're learning a new skill!  If you're TOTALLY new to this concept, <a href="http://help.github.com/mac-git-installation/">I recommend using git</a>, but it's entirely up to you.  <a href="http://github.com/huronschools/luggage">I maintain a git repository of my Luggage fork</a> that's open to anyone to review and borrow.  If you decide to use something like Git, well then GOOD ON YA, MAN!  If not, make sure you have a backup of your Makefiles.  They're small files; make two backups :)</p>

<h2>Package Creation Examples</h2>

<p>Now that we've described how make works, how luggage.make works, given a quick example of how to create a package in 5 lines, and had the installation/backup talk let's walk you through some basic package creation examples. We'll create packages that install an application, create a package that installs printers and executes a postinstall script, create a package that installs source code in many directories, and finally create a complex Makefile that uses variables and bash commands.</p>

<h2>An Application Package</h2>

<p>The most common packages will simply install an application file into the /Applications folder on your computer.  Since .app files are actually bundles (a directory that contains subdirectories of executable code), we will need to use tar to wrap these bundles into a single file.  From there we can have The Luggage untar the application into the correct folder. <a href="https://github.com/unixorn/luggage/blob/master/examples/firefox/Makefile">Joe's Firefox example</a> does this, but he also has an added step of curling the tarred/bzipped application from a web server.  I'm going to skip that step (for now) so you understand how the basic process works, but it's a best practice to use the curl method so you can keep your applications up-to-date on your fileserver without having to copy the new files to your luggage directory every time.</p>

<p>Let's first create the /usr/local/share/luggage/examples/calculator directory and then make a copy of /Applications/Calculator.app into the /usr/local/share/luggage/examples/calculator directory.  Next, lets open Terminal and change to our /usr/local/share/luggage/examples/calculator directory.  Finally, run the following command to tar.bz2 our Calculator.app:</p>

<p>``` bash</p>

<pre><code>    tar cvfj Calculator.app.tar.bz2 Calculator.app
</code></pre>

<p>```</p>

<p>If you did it correctly, it should create the Calculator.app.tar.bz2 file that we need for The Luggage.  Make sure this file is in the SAME directory (and level - so don't create subfolders) as the Makefile we're going to create.  You can actually delete the Calculator.app copy that we created - we won't need it.  From there, our Makefile is simple - it should look like this:</p>

<p>``` make</p>

<pre><code>include /usr/local/share/luggage/luggage.make

TITLE=Calculator_Install
REVERSE_DOMAIN=com.yourdomain
PAYLOAD=unbz2-applications-Calculator.app
</code></pre>

<p>```</p>

<p>That's it!  The PAYLOAD variable is the magic variable here - it contains the rule(s) that are to be executed in creating our package.  The unbz2-applications-% File Packaging Rule is defined in our luggage.make file (which we've included at the top of our Makefile), so we don't NEED anything else in our Makefile.  <strong>MAKE SURE</strong> that the capitalization and spelling of Calculator.app in "unbz2-applications-Calculator.app" and your "Calculator.app.tar.bz2" files are IDENTICAL or this package will NOT be created (make relies on this).</p>

<h2>UPDATED: An easier Application Package</h2>

<p>Joe has actually created a Ruby script that will perform all of the actions outlined in the previous example for you.  It's called app2luggage.rb and it can save you a few steps if you know how to use it.  Let's take a look and see what we need to use it.</p>

<p>The first thing you will need to do is install the trollop rubygem as that's what app2luggage.rb uses to parse its options.  You can do this with the following command:</p>

<p>``` bash</p>

<pre><code>    sudo gem install trollop
</code></pre>

<p>```</p>

<p>Next, make sure the app2luggage.rb script exists in your /usr/local/share/luggage directory.  Finally, let's run the command with the following arguments:</p>

<p>``` bash</p>

<pre><code>    sudo /usr/local/share/luggage/app2luggage.rb -a /Applications/Calculator.app -i /usr/local/share/luggage/examples/Calculator_Application/ -l /usr/local/share/luggage/luggage.make -r com.huronhs -p Calculator_Application
</code></pre>

<p>```</p>

<p>Here's what each argument means:</p>

<ol>
<li>-a is the path to the Application we want to tar up and install with The Luggage - we're using the path to Calculator.app for now</li>
<li>-i is the path to the folder that app2luggage.rb will create that contains our Makefile and tarred up application.  This folder SHOULD NOT EXIST or app2luggage.rb will exit (so as not to overwrite your data).</li>
<li>-l is the path to our luggage.make file</li>
<li>-r is the reverse domain for our organization</li>
<li>-p is the package id for the Makefile</li>
</ol>


<p>There are other arguments available, simply run app2luggage.rb with the --help argument to see them all.  Once app2luggage.rb runs successfully, it will create the directory you specified in the -i argument and populate it with a Makefile and the tarred up application.  The only thing left to do is to make your pkg, zip, or dmg.</p>

<h2>Installing a printer with a preinstall script</h2>

<p>One of the most popular solutions I offer with using The Luggage is to create a package that will install a printer and then install a pre-configured PPD file that sets all the initial settings for the printer.  I do this with Puppet currently, and I know it's popular in Munki too.  You can also optionally install a specific driver (if the drivers for your printer aren't already on your machines).  For those people who like to skip ahead, <a href="https://github.com/huronschools/luggage/tree/master/examples/hhs_printers/Printserver%20Managed/Office_9050">I have this example on my luggage repo</a>.</p>

<p>This Makefile demonstrates the use of a preinstall/preflight script (which isn't actually installed into the payload of the package).  The Luggage has a special packaging rule for this called pack-script-% that works so long as the name of your script corresponds exactly with what you write in the PAYLOAD variable.  This file also demonstrates the use of multiple rules in the PAYLOAD variable by using the \ character.  While this isn't difficult to understand, it is a necessary syntax.</p>

<p><a href="https://github.com/huronschools/luggage/blob/master/examples/hhs_printers/Printserver%20Managed/Office_9050/preflight">My preflight script is right here</a> for those who are interested.  It's copied into the directory we create that contains our makefile and I name it preflight.  Note that it contains variables that need to be changed (all of which are at the top of the script) before you deploy this package.</p>

<p>Next, we need to get a .ppd file that contains all the configuration data for our printer.  The easiest way to do this is to install your printer on a demo machine using the EXACT SAME SETTINGS that will be configured in your script (protip: actually RUN the script on your computer first), configure it how you want (number of trays, memory settings, type of finisher, etc...), and then open the /etc/cups/ppd directory on your model computer.  Inside should be a .ppd file for your printer containing all the settings you've just configured.  Copy this .ppd file into the folder that contains your Makefile and preflight script.  Mine (in this example) will be called psm_HHS_Office_9050.ppd</p>

<p>Now, let's look at our Makefile:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Managed Printer Makefile  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='make'><span class='line'><span class="err">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;pre&gt;&lt;code&gt;include</span> <span class="err">/usr/local/share/luggage/luggage.make</span>
</span><span class='line'>
</span><span class='line'><span class="nv">TITLE</span><span class="o">=</span>HHS_Main_Office_9050_Managed_Installer
</span><span class='line'><span class="nv">REVERSE_DOMAIN</span><span class="o">=</span>com.huronhs
</span><span class='line'><span class="nv">PAYLOAD</span><span class="o">=</span><span class="se">\</span>
</span><span class='line'>    pack-hp-ppd <span class="se">\</span>
</span><span class='line'>    pack-script-preflight
</span><span class='line'>
</span><span class='line'><span class="nf">pack-hp-ppd</span><span class="o">:</span> <span class="m">l_etc_cups_ppd</span>
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./psm_HHS_Office_9050.ppd <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/cups/ppd/psm_HHS_Office_9050.ppd
</span><span class='line'>  @sudo chmod 644 <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/cups/ppd/psm_HHS_Office_9050.ppd
</span><span class='line'>  @sudo chown root:_lp <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/cups/ppd/psm_HHS_Office_9050.ppd
</span><span class='line'><span class="err">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The first thing you should notice is that our PAYLOAD variable starts with a \ and has three lines.  The \ signifies that the contents of our variable spans multiple lines.  In reality, the value of PAYLOAD is actually "pack-hp-ppd pack-script-preflight" but it's formatted so it's easier to read.  Next, notice that the pack-script-preflight rule contains the word "preflight" after pack-script-.  This means that our script must be named preflight (EXACTLY - case is sensitive here).  Finally, we've also specified a pack-hp-ppd rule.  Since luggage.make DOES NOT define this rule, we've defined it in our Makefile.</p>

<p>The pack-hp-ppd rule has a dependency on the l_etc_cups_ppd rule.  This rule IS defined in luggage.make (well, it is for me - I can't remember if I created it or not.  If it isn't there for you, then you'll need to create it using the other folder creation rules as a guide) - and it creates the /etc/cups/ppd folder structure that we need in our package.  Lets look at the three lines which are called our <strong>recipe</strong>*:</p>

<p>``` make</p>

<pre><code>@sudo ${CP} ./psm_HHS_Office_9050.ppd ${WORK_D}/etc/cups/ppd/psm_HHS_Office_9050.ppd
@sudo chmod 644 ${WORK_D}/etc/cups/ppd/psm_HHS_Office_9050.ppd
@sudo chown root:_lp ${WORK_D}/etc/cups/ppd/psm_HHS_Office_9050.ppd
</code></pre>

<p>```</p>

<p>The first line references the CP variable (if you remember - its value is /bin/cp) to copy the psm_HHS_Office_9050.ppd file from the directory that contains our Makefile into Luggage's working directory/etc/cups/ppd.  The second line sets its mode to 644 (to match the mode for all .ppd files in that directory), and the third line sets the owner to root and the group to _lp (note that this group is ONLY available in 10.5 and 10.6 machines - so you'll need another package for 10.4 clients or below).</p>

<p>That's it!  The resultant package will run the preflight script and then install the correct .ppd file after the script is run.  This package will successfully install and configure your printer in one fell swoop.</p>

<h2>Installing files into multiple directories</h2>

<p>So far our Makefiles have been pretty easy.  In fact, most of them have been a couple of lines.  Lets look at a package that installs files into multiple locations.  There's a cool open source tool called <a href="http://github.com/ripienaar/angelia">Angelia that was created by R.I Pienaar</a>.  I use it to send alerts to my iPhone and to also process Nagios Alerts.  The problem is that it's only packaged for Linux machines.  Since I manage Mac machines, I thought I'd lend R.I. a hand and create a package installer for it.  <a href="https://github.com/huronschools/luggage/tree/master/examples/angelia">This package is also on my luggage repo</a> if you want to work ahead.  Let's look at the Makefile:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Angelia Recipe  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='make'><span class='line'><span class="err">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;pre&gt;&lt;code&gt;#  Angelia Package Creation</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="cp">include /usr/local/share/luggage/luggage.make</span>
</span><span class='line'>
</span><span class='line'><span class="nv">TITLE</span><span class="o">=</span>Angelia_Installer
</span><span class='line'><span class="nv">REVERSE_DOMAIN</span><span class="o">=</span>com.huronhs
</span><span class='line'><span class="nv">PAYLOAD</span><span class="o">=</span><span class="se">\</span>
</span><span class='line'>    pack-angelia-etc <span class="se">\</span>
</span><span class='line'>    pack-angelia-binaries <span class="se">\</span>
</span><span class='line'>    pack-angelia-lib <span class="se">\</span>
</span><span class='line'>    pack-angelia-spool <span class="se">\</span>
</span><span class='line'>    pack-angelia-log <span class="se">\</span>
</span><span class='line'>    pack-angelia-launchd
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nf">pack-angelia-launchd</span><span class="o">:</span> <span class="m">l_Library_LaunchDaemons</span>
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> net.devco.angelia.plist <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/Library/LaunchDaemons
</span><span class='line'>  @sudo chmod -R 644 <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/Library/LaunchDaemons
</span><span class='line'>
</span><span class='line'><span class="nf">pack-angelia-binaries</span><span class="o">:</span> <span class="m">l_usr_sbin</span>
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./angelia-send.rb <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/usr/sbin/angelia-send
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./angelia-spoold.rb <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/usr/sbin/angelia-spoold
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./angelia-nagios-send.rb <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/usr/sbin/angelia-nagios-send
</span><span class='line'>  @sudo chmod -R 755 <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/usr/sbin
</span><span class='line'>
</span><span class='line'><span class="nf">pack-angelia-lib</span><span class="o">:</span> <span class="m">l_Library_Ruby_Site_1_8</span>
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> -R ./angelia <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/Library/Ruby/Site/1.8
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./angelia.rb <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/Library/Ruby/Site/1.8
</span><span class='line'>  @sudo chmod -R 755 <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/Library/Ruby/Site/1.8
</span><span class='line'>
</span><span class='line'><span class="nf">pack-angelia-etc</span><span class="o">:</span> <span class="m">l_etc_angelia</span>
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> -R ./templates <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/angelia
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./angelia.cfg <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/angelia
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./COPYING <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/angelia
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">CP</span><span class="k">}</span> ./README.markdown <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/angelia
</span><span class='line'>  @sudo chmod -R 755 <span class="k">${</span><span class="nv">WORK_D</span><span class="k">}</span>/etc/angelia
</span><span class='line'>
</span><span class='line'><span class="nf">pack-angelia-log</span><span class="o">:</span> <span class="m">l_var_log_angelia</span>
</span><span class='line'>  @sudo touch .create
</span><span class='line'><span class="nf">pack-angelia-spool</span><span class="o">:</span> <span class="m">l_var_spool_angelia</span>
</span><span class='line'>  @sudo touch .create
</span><span class='line'><span class="err">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It's definitely longer, but I don't think it's any more complex than the examples we've seen before.  The PAYLOAD variable spans multiple lines using the \ character and I've defined all the custom rules.  All of the rules depend on <a href="https://github.com/huronschools/luggage/blob/master/luggage.make">folder rules in my luggage.make file</a> (which were created if they didn't exist before), and the recipes inside those rules are extremely simple to navigate (mainly copying files and changing permissions).  Creating a script that makes this package would be QUITE A BIT longer than this Makefile, and the Makefile itself took less than 3 minutes to create.  The only caveat is that we need to make sure all the files/directories we're copying into Luggage's WORK_D directory are in the folder that contains the Makefile.  Because of this, anytime Angelia is updated I will need to copy over new files.</p>

<p>It would be much easier to create a Makefile that downloaded the current version of all of these files before it copied them into our package...</p>

<h2>Creating a more complex Makefile</h2>

<p>The basis of this example was my thought that it would be MUCH easier for me to have a Makefile that downloaded the newest versions of the files that I need before it copies them into the package.  Make supports this through its support of shell commands and variables - it only requires you to code it up.  Let's look at a package I created for Marionette-Collective.</p>

<p><a href="http://github.com/puppetlabs/marionette-collective">Marionette-Collective is awesome software</a> (also created by R.I Pienaar and now owned by Puppet Labs) that allows you to communicate with multiple nodes at once.  They DID have a script that created their packages, but I wanted to create a Makefile that would create a package of ANY version of their software.  Let's look at the Makefile first and I'll break it down:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>MCollective Recipe  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
</pre></td><td class='code'><pre><code class='make'><span class='line'><span class="err">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nf">&lt;pre&gt;&lt;code&gt;#  Example</span><span class="o">:</span>  <span class="m">A dynamic installer for Marionette-Collective</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Author:  Gary Larizza</span>
</span><span class='line'><span class="c">#  Created: 12/17/2010</span>
</span><span class='line'><span class="c">#  Last Modified: 12/18/2010</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Description:  This Makefile will download the version of MCollective specified</span>
</span><span class='line'><span class="c">#    in the PACKAGE_VERSION variable from the Puppet Labs website, untar it,</span>
</span><span class='line'><span class="c">#    and then install the source files into their Mac-specific locations.  </span>
</span><span class='line'><span class="c">#    The MAJOR and MINOR versions must be specified for the Info.plist file</span>
</span><span class='line'><span class="c">#    that Packagemaker requires, but I use awk on the PACKAGE_VERSION to </span>
</span><span class='line'><span class="c">#    get these.  See inline comments.</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="cp">include /usr/local/share/luggage/luggage.make</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c"># Luggage Variables:</span>
</span><span class='line'><span class="c">#    If the TYPE variable isn&#39;t specified via the CLI, we will install everything</span>
</span><span class='line'><span class="c">#    into the resultant package</span>
</span><span class='line'><span class="nv">TITLE</span><span class="o">=</span>MCollective_Installer_Full
</span><span class='line'><span class="nv">REVERSE_DOMAIN</span><span class="o">=</span>com.puppetlabs
</span><span class='line'><span class="nv">PAYLOAD</span><span class="o">=</span><span class="se">\</span>
</span><span class='line'>    unpack-mc-<span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span> <span class="se">\</span>
</span><span class='line'>    pack-mc-libexec <span class="se">\</span>
</span><span class='line'>    pack-mc-binaries <span class="se">\</span>
</span><span class='line'>    pack-mc-lib <span class="se">\</span>
</span><span class='line'>    pack-mc-config <span class="se">\</span>
</span><span class='line'>    pack-mc-config-server <span class="se">\</span>
</span><span class='line'>    pack-mc-config-client <span class="se">\</span>
</span><span class='line'>    pack-mc-launchd <span class="se">\</span>
</span><span class='line'>    pack-mc-mcollectived <span class="se">\</span>
</span><span class='line'>    pack-mc-preflight-all
</span><span class='line'>
</span><span class='line'><span class="c"># Variable Declarations:  </span>
</span><span class='line'><span class="c">#    Any variable can be set from the command line by doing this:</span>
</span><span class='line'><span class="c">#    &quot;make pkg PACKAGE_VERSION=1.0.0&quot;</span>
</span><span class='line'><span class="nv">PACKAGE_VERSION</span><span class="o">=</span>1.0.0
</span><span class='line'><span class="nv">PACKAGE_MAJOR_VERSION</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="k">${</span><span class="nv">PACKAGE_VERSION</span><span class="k">}</span> | awk -F <span class="s1">&#39;.&#39;</span> <span class="s1">&#39;{print $$1}&#39;</span><span class="sb">`</span>
</span><span class='line'><span class="nv">PACKAGE_MINOR_VERSION</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="k">${</span><span class="nv">PACKAGE_VERSION</span><span class="k">}</span> | awk -F <span class="s1">&#39;.&#39;</span> <span class="s1">&#39;{print $$2$$3}&#39;</span><span class="sb">`</span>
</span><span class='line'><span class="nv">MCFILE</span><span class="o">=</span>mcollective-<span class="k">${</span><span class="nv">PACKAGE_VERSION</span><span class="k">}</span>
</span><span class='line'><span class="nv">MCURL</span><span class="o">=</span>http://puppetlabs.com/downloads/mcollective/<span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span>.tgz
</span><span class='line'>
</span><span class='line'><span class="c"># Package Creation Limiters:</span>
</span><span class='line'><span class="c">#    These if-statements will check for one of three values for the TYPE variable:</span>
</span><span class='line'><span class="c">#    &quot;COMMON, CLIENT, or BASE&quot;  If either of these values are present (CASE SENSITIVE)</span>
</span><span class='line'><span class="c">#    the PAYLOAD variable will be changed to limit what is installed into the package.</span>
</span><span class='line'>
</span><span class='line'><span class="c"># COMMON Package:</span>
</span><span class='line'><span class="c">#    This package includes the Ruby libraries and MCollective plugins with nothing else.</span>
</span><span class='line'><span class="cp">ifeq (${TYPE},COMMON)</span>
</span><span class='line'>  <span class="nv">PAYLOAD</span><span class="o">=</span><span class="se">\</span>
</span><span class='line'>      unpack-mc-<span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span> <span class="se">\</span>
</span><span class='line'>      pack-mc-libexec <span class="se">\</span>
</span><span class='line'>      pack-mc-lib <span class="se">\</span>
</span><span class='line'>      pack-mc-preflight-common
</span><span class='line'>  <span class="nv">TITLE</span><span class="o">=</span>MCollective_Installer_Common
</span><span class='line'><span class="cp">endif</span>
</span><span class='line'>
</span><span class='line'><span class="c"># CLIENT Package:</span>
</span><span class='line'><span class="c">#    This package includes the MCollective Binaries and the configuration file for</span>
</span><span class='line'><span class="c">#    MCollective&#39;s client binaries.  </span>
</span><span class='line'><span class="cp">ifeq (${TYPE},CLIENT)</span>
</span><span class='line'>  <span class="nv">PAYLOAD</span><span class="o">=</span><span class="se">\</span>
</span><span class='line'>      unpack-mc-<span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span> <span class="se">\</span>
</span><span class='line'>      pack-mc-config <span class="se">\</span>
</span><span class='line'>      pack-mc-binaries <span class="se">\</span>
</span><span class='line'>      pack-mc-config-client <span class="se">\</span>
</span><span class='line'>      pack-mc-preflight-client
</span><span class='line'>  <span class="nv">TITLE</span><span class="o">=</span>MCollective_Installer_Client
</span><span class='line'><span class="cp">endif</span>
</span><span class='line'>
</span><span class='line'><span class="c"># BASE Package:</span>
</span><span class='line'><span class="c">#    This package includes the mcollectived daemon, Ruby Libraries, a launchd plist</span>
</span><span class='line'><span class="c">#    to call mcollectived, and the configuration files for the MCollective server.</span>
</span><span class='line'><span class="cp">ifeq (${TYPE},BASE)</span>
</span><span class='line'>  <span class="nv">PAYLOAD</span><span class="o">=</span><span class="se">\</span>
</span><span class='line'>      unpack-mc-<span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span> <span class="se">\</span>
</span><span class='line'>      pack-mc-config <span class="se">\</span>
</span><span class='line'>      pack-mc-config-server <span class="se">\</span>
</span><span class='line'>      pack-mc-launchd <span class="se">\</span>
</span><span class='line'>      pack-mc-mcollectived <span class="se">\</span>
</span><span class='line'>      pack-mc-lib <span class="se">\</span>
</span><span class='line'>      pack-mc-preflight-base
</span><span class='line'>  <span class="nv">TITLE</span><span class="o">=</span>MCollective_Installer_Base
</span><span class='line'><span class="cp">endif</span>
</span><span class='line'>
</span><span class='line'><span class="c"># This rule will curl the selected version of MCollective and untar it into the directory</span>
</span><span class='line'><span class="c">#    in which the Makefile resides.</span>
</span><span class='line'><span class="nf">unpack-mc-${MCFILE}</span><span class="o">:</span>
</span><span class='line'>  curl <span class="k">${</span><span class="nv">MCURL</span><span class="k">}</span> -o <span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span>.tgz
</span><span class='line'>  @sudo <span class="k">${</span><span class="nv">TAR</span><span class="k">}</span> xzf <span class="k">${</span><span class="nv">MCFILE</span><span class="k">}</span>.tgz
</span><span class='line'>
</span><span class='line'><span class="c"># This rule will install MCollective&#39;s plugin files to /usr/libexec/mcollective</span>
</span><span class='line'><span class="err">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
</feed>
